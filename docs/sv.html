<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Samenvatting – WB1630-20 Statica</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ff63373b1067ca6f91cf1456aa1f00a2.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">WB1630-20 Statica</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./sv.html" aria-current="page"> 
<span class="menu-text">Samenvatting</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./form.html"> 
<span class="menu-text">Formulebladen</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Samenvatting</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="statica-in-een-notendop" class="level1">
<h1>Statica in een notendop</h1>
<p>De derde wet van Newton is: <span class="math display">\sum\overrightharpoon{\mathbf{F}}= m\overrightharpoon{\mathbf{a}}</span> Daarnaast is er een draai-equivalent van de derde wet van Newton<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>: <span class="math display">\sum\overrightharpoon{\mathbf{M}}_G = I_G\overrightharpoon{\mathbf{\alpha}}</span> De som van momenten berekenen we als volgt: <span class="math display">\sum\overrightharpoon{\mathbf{M}}_G = \sum_i \overrightharpoon{\mathbf{r}}_{Gi}\times \overrightharpoon{\mathbf{F}}_i + \sum_j \overrightharpoon{\mathbf{M}}_{ext, j}</span> Het vak Statica behandelt de situaties waar er geen versnelling is<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>: <span class="math display">\sum\overrightharpoon{\mathbf{F}}= \overrightharpoon{\mathbf{0}}</span> <span class="math display">\sum_i \overrightharpoon{\mathbf{r}}_{Gi}\times \overrightharpoon{\mathbf{F}}_i + \sum_j \overrightharpoon{\mathbf{M}}_{ext, j}= \overrightharpoon{\mathbf{0}}</span> Alternatievelijk geldt voor evenwicht:</p>
<ol type="1">
<li><p>Virtuele arbeid is nul. <span class="math display">dU = \sum_i d\overrightharpoon{\mathbf{r}}_i\cdot\overrightharpoon{\mathbf{F}}_i = 0</span></p></li>
<li><p>De afgeleide van de potentiële energie is nul. <span class="math display">\frac{d}{dq}V = \frac{d}{dq}\left(\sum_i m_igh_i(q) + \sum_j\frac{1}{2}k_js_j^2(q)\right)=0</span></p></li>
</ol>
<p>Wat betekent dit allemaal? Wat zijn die pijltjes en dikgedrukte letters? Wat is een moment? Wat is het verschil tussen vermenigvuldigen met een puntje en vermenigvuldigen met een kruisje? Wat is virtuele arbeid? Wat zijn die grote E’s met letters eronder?</p>
<p>Dat staat allemaal in de rest van dit document (en leggen we je graag verder uit tijdens de hoor- en werkcolleges).</p>
</section>
<section id="leerdoelen" class="level1">
<h1>Leerdoelen</h1>
<p>Aan het eind van dit vak zou de student het volgende moeten kunnen:</p>
<ol type="1">
<li><p>Het toepassen van de volgende <strong>vectoroperaties</strong> op wiskundige vraagstukken: optellen, aftrekken, scalair vermenigvuldigen, magnitude bepalen, normaliseren, inproduct, uitproduct, component bepalen, projecteren, onderlinge hoek bepalen; en op natuurkundige vraagstukken: arbeid bepalen gegeven een constante krachtvector en verplaatsing, momentvector bepalen gegeven een krachtvector en positievectoren, moment langs een as bepalen gegeven een momentvector en positievectoren.</p></li>
<li><p>Een <strong>systeem modelleren</strong> als één of meer puntdeeltjes of starre lichamen, of een combinatie daarvan, in zowel 2D als 3D.</p></li>
<li><p><strong>Vrijlichaamsdiagrammen</strong> tekenen van één of meer puntdeeltjes of starre lichamen, of een combinatie daarvan, in zowel 2D als 3D.</p></li>
<li><p>Evenwichtsvoorwaarden bepalen van één of meer puntdeeltjes of starre lichamen, of een combinatie daarvan, door middel van de <strong>vectormethode</strong>, in zowel 2D als 3D.</p></li>
<li><p>De <strong>resulterende kracht</strong> bepalen van twee of meer krachten, en de <strong>werklijn</strong> van de resulterende kracht bepalen, in zowel 2D als 3D. In 3D alleen als alle krachten parallel lopen.</p></li>
<li><p>De resulterende kracht en de werklijn daarvan bepalen van één of meer <strong>verdeelde belastingen</strong>, door middel van zowel de <strong>superpositiemethode</strong> als de <strong>integratiemethode</strong>.</p></li>
<li><p>Evenwichtsvoorwaarden bepalen van een gegeven <strong>vakwerk</strong>, door middel van zowel de <strong>knooppuntmethode</strong> als de <strong>snedemethode</strong>, in zowel 2D als 3D.</p></li>
<li><p><strong>Nulstaven</strong> (zero force members) en <strong>tweekrachtsstaven</strong> (two force members) identificeren, en daarmee vrijlichaamsdiagrammen versimpelen.</p></li>
<li><p>De <strong>inwendige belasting</strong> bepalen, namelijk normaalkracht, schuifkracht, en buigmoment, op gegeven posities van een gegeven 2D balk.</p></li>
<li><p><strong>Schuifkracht- en buigmomentdiagrammen</strong> tekenen van een gegeven 2D balk.</p></li>
<li><p>Evenwichtsvoorwaarden bepalen van één of meer starre lichamen waarop <strong>Coulombwrijving</strong>, <strong>riemwrijving</strong>, <strong>rolweerstand</strong>, of een combinatie daarvan, van toepassing is.</p></li>
<li><p>Evenwichtsvoorwaarden bepalen van mechanismen in 2D, door middel van de <strong>virtuele arbeidmethode</strong> en de <strong>potentiële energiemethode</strong>.</p></li>
<li><p><strong>Stabiliteit</strong> bepalen van een evenwichtssituatie van een mechanisme in 2D, door middel van de <strong>potentiële energiemethode</strong>.</p></li>
<li><p>Het <strong>geometrisch centrum</strong> bepalen van curvesegmenten, oppervlakken, en volumes, door middel van zowel <strong>superpositie</strong> als de <strong>integratiemethode</strong>.</p></li>
<li><p>Evenwichtsvoorwaarden bepalen van één of meer starre lichamen waarop <strong>hydrostatische belasting</strong> van toepassing is.</p></li>
</ol>
</section>
<section id="vectoren" class="level1">
<h1>Vectoren</h1>
<p>Notatie: het is gebruikelijk dat vectoren getypt dikgedrukt zijn (<span class="math inline">\mathbf{r}</span>). Handgeschreven is het gebruikelijk om ze aan te duiden met een pijl erboven <span class="math inline">\overrightharpoon{r}</span>. In dit document gebruiken we beide (<span class="math inline">\overrightharpoon{\mathbf{r}}</span>). Vectoren met lengte 1 noteren we dikgedrukt met een dakje (<span class="math inline">\hat{\mathbf{u}}</span>).</p>
<p>Basis-eenheidsvectoren: <span class="math display">\hat{\mathbf{i}}= \begin{pmatrix} 1 \\ 0 \\ 0 \end{pmatrix}, \quad \hat{\mathbf{j}}= \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix}, \quad \hat{\mathbf{k}}= \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix}</span></p>
<p>Notatie met basisvectoren: <span class="math display">\overrightharpoon{\mathbf{r}} = \begin{pmatrix} a \\ b \\ c \end{pmatrix}=a\hat{\mathbf{i}}+b\hat{\mathbf{j}}+c\hat{\mathbf{k}}, \quad \overrightharpoon{\mathbf{s}} = d\hat{\mathbf{i}}+ e\hat{\mathbf{j}}+ f\hat{\mathbf{k}}</span></p>
<p>Optellen: <span class="math display">\overrightharpoon{\mathbf{r}} + \overrightharpoon{\mathbf{s}} = (a+d)\hat{\mathbf{i}}+ (b+e)\hat{\mathbf{j}}+ (c+f)\hat{\mathbf{k}}</span></p>
<p>Scalair vermenigvuldigen: <span class="math display">g\overrightharpoon{\mathbf{r}} = ga\hat{\mathbf{i}}+ gb\hat{\mathbf{j}}+ gc\hat{\mathbf{k}}</span></p>
<p>Aftrekken: <span class="math display">\overrightharpoon{\mathbf{r}} - \overrightharpoon{\mathbf{s}} = \overrightharpoon{\mathbf{r}} + (-1)\overrightharpoon{\mathbf{s}}</span></p>
<p>Positievectoren: <span class="math display">\overrightharpoon{\mathbf{r}}_{O B} = \overrightharpoon{\mathbf{r}}_{O A} + \overrightharpoon{\mathbf{r}}_{A B}</span> <span class="math display">\overrightharpoon{\mathbf{r}}_{A B} = \overrightharpoon{\mathbf{r}}_{O B} - \overrightharpoon{\mathbf{r}}_{O A}</span></p>
<p>Magnitude: <span class="math display">r = ||\overrightharpoon{\mathbf{r}}|| = \sqrt{a^2+b^2+c^2}\quad\leftarrow\text{Zorg dat er altijd duidelijk onderscheid is tussen $r$ en $\overrightharpoon{\mathbf{r}}$}</span></p>
<p>Eenheidsvector (normalizeren): <span class="math display">\hat{\mathbf{u}}_r = \frac{1}{r}\overrightharpoon{\mathbf{r}}</span></p>
</section>
<section id="krachtvectoren" class="level1">
<h1>Krachtvectoren</h1>
<p>Algemene splitsing in grootte en richting: <span class="math display">\overrightharpoon{\mathbf{F}}=F\hat{\mathbf{u}}_F</span></p>
<p>In 2D als je een hoek <span class="math inline">\theta</span> hebt vanaf de positieve x-as linksom: <span class="math display">\overrightharpoon{\mathbf{F}}=F(\hat{\mathbf{i}}\cos\theta +\hat{\mathbf{j}}\sin\theta)</span></p>
</section>
<section id="inproduct" class="level1">
<h1>Inproduct</h1>
<p>Inproduct: <span class="math display">\overrightharpoon{\mathbf{r}} \cdot \overrightharpoon{\mathbf{s}}= ad+be+cf \quad\leftarrow\text{Dit is dus een scalar!}</span> Met een hoek <span class="math inline">\theta</span> tussen <span class="math inline">\overrightharpoon{\mathbf{r}}</span> en <span class="math inline">\overrightharpoon{\mathbf{s}}</span>: <span class="math display">\overrightharpoon{\mathbf{r}} \cdot \overrightharpoon{\mathbf{s}}= rs\cos\theta</span></p>
<p>Scalaire component van <span class="math inline">\overrightharpoon{\mathbf{r}}</span> langs <span class="math inline">\overrightharpoon{\mathbf{s}}</span>: <span class="math display">\text{comp} _s(\overrightharpoon{\mathbf{r}})=\overrightharpoon{\mathbf{r}}\cdot\hat{\mathbf{u}}_s\quad\leftarrow\text{Dit is dus een scalar!}</span></p>
<p>Projectie(vector) van <span class="math inline">\overrightharpoon{\mathbf{r}}</span> op <span class="math inline">\overrightharpoon{\mathbf{s}}</span>: <span class="math display">\overrightharpoon{\mathbf{\text{proj}}} _s(\overrightharpoon{\mathbf{r}})=\text{comp} _s(\overrightharpoon{\mathbf{r}})\hat{\mathbf{u}}_s\quad\leftarrow\text{Dit is dus een vector!}</span></p>
<p>Arbeid van een constante kracht: <span class="math display">U = \overrightharpoon{\mathbf{F}}\cdot \Delta\overrightharpoon{\mathbf{r}}</span></p>
<p>Infinitesimale arbeid: <span class="math display">dU = \overrightharpoon{\mathbf{F}}\cdot d\overrightharpoon{\mathbf{r}}</span></p>
<p>Algemene arbeid (over een pad <span class="math inline">C</span>): <span class="math display">U=\int_C\overrightharpoon{\mathbf{F}}\cdot d\overrightharpoon{\mathbf{r}}</span></p>
</section>
<section id="vrijlichaamsdiagram" class="level1">
<h1>Vrijlichaamsdiagram</h1>
<p>Een vrijlichaamsdiagram (“free body diagram”, FBD) bevat het volgende.</p>
<ol type="1">
<li><p>Het lichaam naar keuze, en <strong>niet</strong> de omgeving.</p>
<p>Teken de systeemgrens zodanig dat de krachten die je wilt bepalen, op de systeemgrens werken. Bijvoorbeeld: als je de kracht wil bepalen die de grond op een wiel uitoefent, moet je systeemgrens door dat contactpunt heen lopen.</p></li>
<li><p>Alle (aangrijpings)punten waarop krachten werken.</p></li>
<li><p>Alle krachten en externe (koppel)momenten<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> die op het lichaam werken.</p>
<p>Let op: teken de krachten die de omgeving op het lichaam uitoefent (dus niet de tegenovergestelde krachten die het lichaam op de omgeving uitoefent).</p>
<p>Als een kracht een bekende richting heeft, teken je één kracht met een onbekende grootte, en geef je die grootte een naam (bijvoorbeeld <span class="math inline">A_x</span>).</p>
<p>Als een kracht ook geen bekende richting hebt, moet je dus twee onbekenden hebben. Bijvoorbeeld twee krachten met bekende richtingen, loodrecht op elkaar, en met twee onbekende groottes (<span class="math inline">A_x</span> en <span class="math inline">A_y</span>).<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>Als er op een lichaam een verdeelde belasting werkt, raad ik aan om die alvast te vervangen door een puntbelasting (met de juiste werklijn), voordat je je vrijlichaamsdiagram tekent<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p></li>
<li><p>Alle afstanden die invloed hebben op het momentevenwicht.</p>
<p>Bijvoorbeeld afstanden tussen krachten en afstanden vanaf het zwaartepunt.</p></li>
<li><p>Een assenstelsel.</p></li>
</ol>
<p>Een vrijlichaamsdiagram zou alle informatie moeten bevatten die je nodig hebt om een probleem op te lossen, en geen informatie die je niet nodig hebt.</p>
</section>
<section id="krachtenevenwicht-puntdeeltje" class="level1">
<h1>Krachtenevenwicht puntdeeltje</h1>
<ol type="1">
<li><p>Teken een vrijlichaamsdiagram. Dit is de belangrijkste stap.</p></li>
<li><p>Check of alle krachten door één punt gaan.</p></li>
<li><p>Check of er twee onbekenden zijn in 2D, of drie onbekenden in 3D. Voorbeeld: onbekenden <span class="math inline">F_1, F_2, F_3</span>.</p></li>
<li><p>Voorbeeld: <span class="math inline">F_4</span> bekend. Dan:</p>
<p><span class="math display">\sum\overrightharpoon{\mathbf{F}}= \overrightharpoon{\mathbf{0}} = \overrightharpoon{\mathbf{F}}_1 + \overrightharpoon{\mathbf{F}}_2 + \overrightharpoon{\mathbf{F}}_3 + \overrightharpoon{\mathbf{F}}_4</span></p></li>
<li><p>Elke kracht omschrijven als een eenheidsvector keer een grootte: <span class="math display">\sum\overrightharpoon{\mathbf{F}}= \hat{\mathbf{u}}_1F_1 + \hat{\mathbf{u}}_2F_2 + \hat{\mathbf{u}}_3F_3 + \hat{\mathbf{u}}_4F_4</span></p></li>
<li><p>Opdelen in componenten:</p>
<p><span class="math display">(\hat{\mathbf{u}}_1\cdot\hat{\mathbf{i}}) F_1 + (\hat{\mathbf{u}}_2\cdot\hat{\mathbf{i}}) F_2 + (\hat{\mathbf{u}}_3\cdot\hat{\mathbf{i}}) F_3 + (\hat{\mathbf{u}}_4\cdot\hat{\mathbf{i}}) F_4 = 0</span></p>
<p><span class="math display">(\hat{\mathbf{u}}_1\cdot\hat{\mathbf{j}}) F_1 + (\hat{\mathbf{u}}_2\cdot\hat{\mathbf{j}}) F_2 + (\hat{\mathbf{u}}_3\cdot\hat{\mathbf{j}}) F_3 + (\hat{\mathbf{u}}_4\cdot\hat{\mathbf{j}}) F_4 = 0</span></p>
<p><span class="math display">(\hat{\mathbf{u}}_1\cdot\hat{\mathbf{k}}) F_1 + (\hat{\mathbf{u}}_2\cdot\hat{\mathbf{k}}) F_2 + (\hat{\mathbf{u}}_3\cdot\hat{\mathbf{k}}) F_3 + (\hat{\mathbf{u}}_4\cdot\hat{\mathbf{k}}) F_4 = 0</span></p></li>
<li><p>Dit stelsel van drie vergelijkingen en drie onbekenden oplossen (twee in 2D).</p></li>
<li><p>Controleer de eenheid van je (symbolische) eindantwoord(en).</p></li>
</ol>
</section>
<section id="uitproduct" class="level1">
<h1>Uitproduct</h1>
<p>Het uitproduct is niet hetzelfde als het inproduct! <span class="math display">\overrightharpoon{\mathbf{r}} \times \overrightharpoon{\mathbf{s}}= (bf-ce)\hat{\mathbf{i}}+ (cd-af)\hat{\mathbf{j}}+ (ae-bd)\hat{\mathbf{k}}\quad\leftarrow\text{Dit is dus een vector!}</span> <span class="math display">\overrightharpoon{\mathbf{r}} \times \overrightharpoon{\mathbf{s}} = -(\overrightharpoon{\mathbf{s}} \times \overrightharpoon{\mathbf{r}}) \quad\leftarrow\text{Je kan een uitproduct dus niet zomaar omdraaien!}</span> <span class="math display">||\overrightharpoon{\mathbf{r}}\times\overrightharpoon{\mathbf{s}}||=rs\sin\theta</span></p>
<p>Er zijn dus in totaal drie manieren om een vector te “vermenigvuldigen”:</p>
<ol type="1">
<li><p>Scalair product: <span class="math inline">s(a\hat{\mathbf{i}}+b\hat{\mathbf{j}}+c\hat{\mathbf{k}}) = sa\hat{\mathbf{i}}+ sb\hat{\mathbf{j}}+sc\hat{\mathbf{k}}</span></p></li>
<li><p>Inproduct: <span class="math inline">(a\hat{\mathbf{i}}+b\hat{\mathbf{j}}+c\hat{\mathbf{k}})\cdot(d\hat{\mathbf{i}}+e\hat{\mathbf{j}}+f\hat{\mathbf{k}})=ad+be+cf</span></p></li>
<li><p>Uitproduct: <span class="math inline">(a\hat{\mathbf{i}}+b\hat{\mathbf{j}}+c\hat{\mathbf{k}})\times(d\hat{\mathbf{i}}+e\hat{\mathbf{j}}+f\hat{\mathbf{k}})=(bf-ce)\hat{\mathbf{i}}+(cd-af)\hat{\mathbf{j}}+(ae-bd)\hat{\mathbf{k}}</span></p></li>
</ol>
<p>Let op de drie verschillende notaties die we hier dus voor gebruiken.</p>
</section>
<section id="moment" class="level1">
<h1>Moment</h1>
<ol type="1">
<li><p>Een moment is het draai-equivalent van een kracht. Een moment is een vector, want een moment heeft een grootte en een richting.</p></li>
<li><p>Een momentvector loopt parallel aan de as, waaromheen dit moment een draaiing zou veroorzaken.</p></li>
<li><p>De richting van een momentvector wordt bepaald met de <strong>rechterhandregel</strong>: als je met je rechterhand de momentvector vast zou grijpen, zodat je vingers wijzen in de richting van de draaiing, staat je duim in de richting van de pijlpunt.</p></li>
<li><p>Het moment dat een kracht <span class="math inline">\overrightharpoon{\mathbf{F}}_B</span> levert om een punt <span class="math inline">A</span>: <span class="math display">\overrightharpoon{\mathbf{M}}_A = \overrightharpoon{\mathbf{r}}_{A B} \times \overrightharpoon{\mathbf{F}}_B</span></p></li>
<li><p>De component van het moment dat een kracht <span class="math inline">\overrightharpoon{\mathbf{F}}_B</span> levert langs een as <span class="math inline">CD</span>: <span class="math display">M_{CD} = \text{comp}_{CD}(\overrightharpoon{\mathbf{M}}_E) = \overrightharpoon{\mathbf{M}}_E\cdot \hat{\mathbf{u}}_{C D}=(\overrightharpoon{\mathbf{r}}_{EB} \times \overrightharpoon{\mathbf{F}}_B)\cdot \hat{\mathbf{u}}_{C D}</span></p>
<p>Hierbij is <span class="math inline">E</span> een willekeurig punt op de lijn <span class="math inline">CD</span>, dus het kan ook <span class="math inline">C</span> of <span class="math inline">D</span> zelf zijn. Verder is <span class="math inline">M_{CD}</span> de component in de richting van <span class="math inline">\hat{\mathbf{u}}_{CD}</span>. Dit is dus negatief als de draaiing in de andere richting is: als je de grootte wilt hebben, moet je dus nog de absolute waarde nemen.</p></li>
</ol>
</section>
<section id="res" class="level1">
<h1>Resulterende kracht</h1>
<ol type="1">
<li><p>Algemeen: Grootte en richting: <span class="math display">\overrightharpoon{\mathbf{F}}_{res} = \overrightharpoon{\mathbf{F}}_A + \overrightharpoon{\mathbf{F}}_B</span></p>
<p><span class="math inline">\overrightharpoon{\mathbf{F}}_{res}</span> grijpt aan op punt <span class="math inline">C</span> als voor elk willekeurig punt <span class="math inline">D</span> geldt: <span class="math display">\overrightharpoon{\mathbf{r}}_{D C}\times\overrightharpoon{\mathbf{F}}_{res} = \overrightharpoon{\mathbf{r}}_{D A}\times\overrightharpoon{\mathbf{F}}_A + \overrightharpoon{\mathbf{r}}_{D B}\times\overrightharpoon{\mathbf{F}}_B</span></p>
<p>Er zijn oneindig veel mogelijke punten <span class="math inline">C</span>, dit is namelijk de werklijn van <span class="math inline">\overrightharpoon{\mathbf{F}}_{res}</span>.</p>
<p>Voor meer krachten (<span class="math inline">i</span> is hier een sommatie-index, dus niet de eenheidsvector): <span class="math display">\overrightharpoon{\mathbf{F}}_{res} = \sum_i\overrightharpoon{\mathbf{F}}_i</span></p>
<p><span class="math inline">\overrightharpoon{\mathbf{F}}_{res}</span> grijpt aan op punt <span class="math inline">C</span> als voor elk willekeurig punt <span class="math inline">D</span> geldt: <span class="math display">\overrightharpoon{\mathbf{r}}_{D C}\times\overrightharpoon{\mathbf{F}}_{res} = \sum_i \overrightharpoon{\mathbf{r}}_{D i}\times\overrightharpoon{\mathbf{F}}_i</span></p>
<p>Opnieuw: er zijn oneindig veel mogelijke punten <span class="math inline">C</span>, dit is namelijk de werklijn van <span class="math inline">\overrightharpoon{\mathbf{F}}_{res}</span>.</p></li>
<li><p>Voor parallele krachten in 2D, elk in <span class="math inline">y</span>-richting: <span class="math display">F_{res} = F_A + F_B</span></p>
<p>Werklijn<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> van <span class="math inline">F_{res}</span>: <span class="math display">\bar{x} = \frac{1}{F_{res}}(x_AF_A+x_BF_B)</span></p>
<p>Voor meer parallele krachten: <span class="math display">F_{res} = \sum_i F_i</span></p>
<p>Werklijn van <span class="math inline">F_{res}</span>: <span class="math display">\bar{x} = \frac{1}{F_{res}}\sum_i \tilde{x}_i F_i</span></p></li>
<li><p>Voor een verdeelde belasting <span class="math inline">w(x)</span> met <span class="math inline">x_0 &lt; x &lt; x_1</span>: <span class="math display">F_{res} = \int_{x_0}^{x_1} w(x) dx</span> <span class="math display">\bar{x} = \frac{1}{F_{res}}\int_{x_0}^{x_1} xw(x)dx</span></p></li>
<li><p>Voor <span class="math inline">w(x)=ax^b</span>, met een constante <span class="math inline">a</span> en <span class="math inline">b</span>, en <span class="math inline">0&lt;x&lt;l</span>, geldt<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>: <span class="math display">\bar{x} = \frac{b+1}{b+2}l</span></p>
<p>Voor een constante <span class="math inline">w</span>, dus <span class="math inline">w(x) = w = wx^0</span>, geldt <span class="math inline">b=0</span> dus <span class="math inline">\bar{x} = \frac{1}{2}l</span>.</p>
<p>Voor een lineair oplopende <span class="math inline">w(x) = w_{max}\frac{x}{l} = \frac{w_{max}}{l}x^1</span> geldt <span class="math inline">b=1</span> dus <span class="math inline">\bar{x} = \frac{2}{3}l</span>.</p></li>
</ol>
</section>
<section id="evenwicht-star-lichaam" class="level1">
<h1>Evenwicht star lichaam</h1>
<ol type="1">
<li><p>Teken een vrijlichaamsdiagram.</p></li>
<li><p>Check of er drie onbekenden zijn in 2D, en zes onbekenden in 3D<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p></li>
<li><p>Voorbeeld: onbekenden <span class="math inline">F_{Ax}, F_{Ay}, F_{Az}, M_{Ax}, M_{Ay}, M_{Az}</span> op punt <span class="math inline">A</span>, en bekenden</p>
<p><span class="math inline">\overrightharpoon{\mathbf{F}}_B,\overrightharpoon{\mathbf{F}}_C,\overrightharpoon{\mathbf{M}}_B,\overrightharpoon{\mathbf{M}}_C</span>, op punten <span class="math inline">B</span> en <span class="math inline">C</span>.</p></li>
<li><p>Krachtenevenwicht opstellen: <span class="math display">\sum\overrightharpoon{\mathbf{F}}= \overrightharpoon{\mathbf{0}} = F_{A,x}\hat{\mathbf{i}}+ F_{A,y}\hat{\mathbf{j}}+ F_{A,z}\hat{\mathbf{k}}+ \overrightharpoon{\mathbf{F}}_B + \overrightharpoon{\mathbf{F}}_C</span></p></li>
<li><p>Elke kracht omschrijven naar een eenheidsvector keer een grootte.</p></li>
<li><p>Dit opdelen in componenten zodat je drie scalaire vergelijkingen overhoudt (in 3D).</p></li>
<li><p>Momentevenwicht opstellen om een handig punt, in dit geval punt <span class="math inline">A</span>: <span class="math display">\sum \overrightharpoon{\mathbf{M}}_A = \overrightharpoon{\mathbf{0}} = \underbrace{\sum_i\overrightharpoon{\mathbf{M}}_{ext, i}}_{\text{externe momenten}} + \underbrace{\sum_{j} \overrightharpoon{\mathbf{r}}_{A,j} \times \overrightharpoon{\mathbf{F}}_j}_{\text{momenten door externe krachten}}</span></p>
<p>Hier zijn <span class="math inline">i</span> en <span class="math inline">j</span> weer een sommatie-indices, in dit voorbeeld: <span class="math display">\sum \overrightharpoon{\mathbf{M}}_A = \overrightharpoon{\mathbf{0}} = M_{Ax}\hat{\mathbf{i}}+ M_{Ay}\hat{\mathbf{j}}+M_{Az}\hat{\mathbf{k}}+\overrightharpoon{\mathbf{M}}_B + \overrightharpoon{\mathbf{M}}_C + \overrightharpoon{\mathbf{r}}_{A B} \times \overrightharpoon{\mathbf{F}}_B + \overrightharpoon{\mathbf{r}}_{A C} \times \overrightharpoon{\mathbf{F}}_C</span></p></li>
<li><p>Hier weer elke kracht omschrijven naar een eenheidsvector keer een grootte.</p></li>
<li><p>Uitproducten uitschrijven.</p></li>
<li><p>Resultaat weer opdelen in componenten zodat je drie extra scalaire vergelijkingen overhoudt (in 3D).</p></li>
<li><p>In totaal heb je dan zes scalaire vergelijkingen en zes onbekenden. Dit kan je dus oplossen.</p></li>
<li><p>Controleer de eenheid van je (symbolische) eindantwoord(en).</p></li>
</ol>
</section>
<section id="vaste-gebonden-en-vrije-vectoren" class="level1">
<h1>Vaste, gebonden, en vrije vectoren</h1>
<ol type="1">
<li><p>Een <strong>vaste vector</strong> (“fixed vector”) verliest zijn betekenis als hij getransleerd wordt. Voorbeelden: positievector van een puntdeeltje; positievector/snelheidsvector/versnellingsvector van een star lichaam; krachtvector als stabiliteit van belang is.</p></li>
<li><p>Een <strong>gebonden vector</strong> (“sliding vector”) kan over zijn werklijn verschoven worden. Voorbeelden: krachtvector als stabiliteit niet van belang is; moment ten gevolge van kracht.</p></li>
<li><p>Twee tegengestelde maar even grote krachten <span class="math inline">F</span> met onderlinge afstand <span class="math inline">d</span> kunnen vervangen worden door een extern moment met grootte <span class="math inline">M=Fd</span>. Dit heet een <strong>koppel</strong>. Hiervan maakt de locatie en de richting van de krachten niet uit; alleen de onderlinge afstand en de richting van het resultante moment<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>. Dit betekent dat zo’n moment een <strong>vrije vector</strong> (“free vector”) is: alleen de richting en grootte zijn van belang; niet de locatie. Meer voorbeelden van een vrije vector: extern moment; moment ten gevolge van koppel; snelheid en versnelling van een puntdeeltje; hoekpositievector/hoeksnelheidsvector/hoekversnellingsvector van een star lichaam.</p></li>
<li><p>Voor momentevenwicht<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> geldt:</p>
<p><span class="math display">\underbrace{\sum \overrightharpoon{\mathbf{M}}_G}_{\text{gebonden}} = \underbrace{\sum\overrightharpoon{\mathbf{M}}_{ext}}_{\text{vrij}} + \underbrace{\sum_{i} \overrightharpoon{\mathbf{r}}_{G i} \times \overrightharpoon{\mathbf{F}}_i}_{\text{gebonden}} = \underbrace{I_G \overrightharpoon{\mathbf{\alpha}}}_{\text{gebonden}}=\overrightharpoon{\mathbf{0}}</span></p>
<p>De bovenstaande gebonden vectoren zijn gebonden aan de keus voor <span class="math inline">G</span> (welk punt je kiest om het moment omheen te bepalen). De term <span class="math inline">I_G\overrightharpoon{\mathbf{\alpha}}</span> wordt overigens pas behandeld bij Dynamica, en hier is het het handigst om het zwaartepunt te kiezen, vandaar de letter <span class="math inline">G</span>.</p></li>
</ol>
</section>
<section id="meerdere-vrijlichaamsdiagrammen" class="level1">
<h1>Meerdere vrijlichaamsdiagrammen</h1>
<ol type="1">
<li><p>Als je een systeem hebt met precies twee contactpunten, waarop alleen krachten werken (dus geen momenten), dan zijn de resultante krachten even groot en tegengesteld, en hebben ze dezelfde werklijn<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>. Dit heet een <strong>tweekrachtsstaaf</strong> (“two force member”).</p></li>
<li><p>Een <strong>vakwerk</strong> bestaat enkel uit two force members. Voor een vakwerk heb je de snedemethode en de knooppuntmethode. Meestal moet je eerst het hele vakwerk als star lichaam beschouwen en de reactiekrachten bepalen, en daarna (een van) deze twee methodes toepassen.</p></li>
<li><p>Gebruik hierbij de tekenafspraak dat een staaf, die op <strong>trek</strong> belast wordt, een <strong>positieve</strong> kracht levert.</p></li>
<li><p><strong>Snedemethode</strong> (in 2D): trek de systeemgrens door drie staven (in 2D) of zes staven (in 3D) heen. Dan heb je een star lichaam met drie onbekende (trek)krachten in de richting van de doorgesneden staven.</p></li>
<li><p><strong>Knooppuntmethode</strong>: elk knooppunt kan je als een puntdeeltje beschouwen, en daarvan kan je het krachtenevenwicht bepalen.</p></li>
<li><p>Een <strong>nulstaaf</strong> (“zero force member”) kan herkend worden aan het feit dat het de enige staaf is van een knooppunt dat (een component heeft dat) in een bepaalde richting loopt.</p></li>
<li><p>Een <strong>frame of mechanisme</strong> bestaat uit meerdere starre lichamen, maar dit zijn niet allemaal two force members. Je hebt in zo’n geval te veel onbekenden om met één vrijlichaamsdiagram uit te rekenen. Je moet dan meerdere vrijlichaamsdiagrammen tekenen, net zolang todat je even veel vergelijkingen als onbekenden hebt. Elk extra vrijlichaamsdiagram levert drie extra vergelijkingen op (in 2D).</p></li>
</ol>
</section>
<section id="inwendige-belasting" class="level1">
<h1>Inwendige belasting</h1>
<ol type="1">
<li><p>Bij een snede door een 2D balk heb je:</p>
<ol type="1">
<li><p>Normaalkracht <span class="math inline">N</span> in de looprichting van de balk.</p></li>
<li><p>Afschuifkracht <span class="math inline">V</span> loodrecht op de balk.</p></li>
<li><p>Buigmoment <span class="math inline">M</span>.</p></li>
</ol></li>
<li><p>Deze krachten kunnen bepaald worden door een vrijlichaamsdiagram te tekenen waarbij de snede onderdeel van de systeemgrens is.</p></li>
<li><p>Door de locatie van de snede als variabele te nemen (bijvoorbeeld <span class="math inline">x</span>) kan je een <span class="math inline">V</span>-diagram en <span class="math inline">M</span>-diagram genereren: <span class="math inline">V(x)</span> en <span class="math inline">M(x)</span>.</p></li>
<li><p>Als je de tekenafspraak<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> gebruikt, geldt overigens:</p>
<p><span class="math display">V(x) = \frac{d}{dx}M(x)</span></p></li>
<li><p>Als er een verdeelde belasting <span class="math inline">w(x)</span> op de balk werkt (en je gebruikt de tekenafspraak), dan geldt ook:</p>
<p><span class="math display">w(x) = \frac{d}{dx}V(x)</span></p></li>
<li><p>Let op dat je vaak meerdere vrijlichaamsdiagrammen nodig hebt.</p></li>
</ol>
</section>
<section id="virtuele-arbeid" class="level1">
<h1>Virtuele arbeid</h1>
<p>Arbeid geleverd door krachten <span class="math inline">\overrightharpoon{\mathbf{F}}_i</span> en verplaatsingen <span class="math inline">\Delta\overrightharpoon{\mathbf{r}}_i</span>: <span class="math display">U = \sum_i\Delta\overrightharpoon{\mathbf{r}}_i\cdot\overrightharpoon{\mathbf{F}}_i</span></p>
<p>Arbeid geleverd door momenten <span class="math inline">\overrightharpoon{\mathbf{M}}_i</span> en rotaties <span class="math inline">\Delta\overrightharpoon{\mathbf{\theta}}_i</span>: <span class="math display">U = \sum_i\Delta\overrightharpoon{\mathbf{\theta}}_i\cdot\overrightharpoon{\mathbf{M}}_i</span></p>
<p>Als een systeem in evenwicht is<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>, geldt voor de virtuele arbeid over kleine<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> (“virtuele”) verplaatsingen <span class="math inline">d\overrightharpoon{\mathbf{r}}</span> en virtuele rotaties <span class="math inline">d\overrightharpoon{\mathbf{\theta}}</span> : <span class="math display">d U = \sum_i d\overrightharpoon{\mathbf{r}}_i\cdot\overrightharpoon{\mathbf{F}}_i + \sum_j d\overrightharpoon{\mathbf{\theta}}_j\cdot\overrightharpoon{\mathbf{M}}_j=  0</span></p>
<ol type="1">
<li><p>Bepaal op welke aangrijpingspunten je de krachten weet en op welk aangrijpingspunt je de kracht wilt bepalen.</p></li>
<li><p>Vind een vrijheidsgraad waarmee deze punten bewegen. Dit is vaak een rotatie, dus vaak wordt <span class="math inline">\theta</span> gebruikt. (Het kan ook een kleine verplaatsing zijn, dan wordt vaak <span class="math inline">s</span> gebruikt.)</p></li>
<li><p>Vind de positievectoren <span class="math inline">\overrightharpoon{\mathbf{r}}_i</span> van deze punten<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>, als functie van <span class="math inline">\theta</span>.</p></li>
<li><p>Vind de afgeleiden <span class="math inline">d\overrightharpoon{\mathbf{r}}_i/d\theta</span>. Schrijf om naar <span class="math inline">d\overrightharpoon{\mathbf{r}}_i=(...)d\theta</span></p></li>
<li><p>Los op <span class="math inline">dU = 0</span>.</p></li>
</ol>
</section>
<section id="potentiële-energie" class="level1">
<h1>Potentiële energie</h1>
<ol type="1">
<li><p>Voor een systeem waarop alleen conservatieve krachten werken, geldt: voor elke vrijheidsgraad <span class="math inline">q</span> is er evenwicht als de potentiële energie <span class="math inline">V</span> daar constant is<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>. Oftewel:</p>
<p><span class="math display">\frac{d}{dq}V(q) = 0</span></p>
<p>Net zoals bij virtuele arbeid hebben we meestal een hoek <span class="math inline">\theta</span> of een afstand <span class="math inline">s</span> als vrijheidsgraad. Maar we schrijven hier steeds <span class="math inline">q</span> om het algemeen te houden.</p></li>
<li><p>Verder is dit evenwicht neutraal stabiel als ook geldt<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a>:</p>
<p><span class="math display">\frac{d^2}{dq^2}V(q) = 0</span></p>
<p>Als de tweede afgeleide positief is, is het evenwicht stabiel; als de tweede afgeleide negatief is, is het evenwicht instabiel.</p></li>
<li><p>Een mechanisme is in elke positie neutraal stabiel als er een oplossing voor <span class="math inline">dV/dq=0</span> is die onafhankelijk is van <span class="math inline">q</span>. Dit wordt ook wel “statisch balanceren” of “zwaartekrachtcompensatie” genoemd.</p></li>
<li><p>Voor een gewicht <span class="math inline">mg</span> en hoogte <span class="math inline">h</span> geldt: <span class="math display">V_g = mgh + C</span></p>
<p>Hier is <span class="math inline">C</span> een (integratie)constante, want je kan het nulpunt van zwaarte-energie (de zogenoemde “datum”) plaatsen waar je wil.</p></li>
<li><p>Voor een veer met stijfheid <span class="math inline">k</span> en uitrekking <span class="math inline">\Delta s</span> geldt: <span class="math display">V_k = \frac{1}{2}k(\Delta s)^2</span></p></li>
<li><p>Voor een ideale veer (“zero free length spring”) geldt dat de uitrekking en de totale lengte van de veer gelijk zijn. Zo’n veer wordt vaak gebruikt bij neutraal stabiele mechanismen.</p></li>
<li><p>Vaak moet je een (veer)lengte bepalen met de cosinusregel:</p>
<p><span class="math display">a^2 = b^2 + c^2 -2bc\cos\alpha</span></p>
<p>Deze moet je uit je hoofd kennen.</p></li>
<li><p>Bij een mechanisme met meerdere vrijheidsgraden <span class="math inline">q_1</span> en <span class="math inline">q_2</span> moet je voor evenwicht hebben:</p>
<p><span class="math display">\frac{d}{dq_1}V(q_1,q_2) = \frac{d}{dq_2}V(q_1,q_2) = 0</span></p>
<p>En voor een neutraal stabiel evenwicht moet je ook hebben:</p>
<p><span class="math display">\frac{d}{dq_1}\frac{d}{dq_1} V(q_1,q_2) = \frac{d}{dq_1} \frac{d}{dq_2}V(q_1,q_2) = \frac{d}{dq_2} \frac{d}{dq_1}V(q_1,q_2) = \frac{d}{dq_2} \frac{d}{dq_2}V(q_1,q_2) = 0</span></p>
<p>Voor een systeem dat voor elke positie neutraal stabiel is, levert dit zesmaal dezelfde vergelijking op; alternatievelijk kan je zien dat er dezelfde oplossing is voor zowel <span class="math inline">dV/dq_1=0</span> en <span class="math inline">dV/dq_2=0</span> die onafhankelijk is van zowel <span class="math inline">q_1</span> als <span class="math inline">q_2</span>.</p></li>
</ol>
</section>
<section id="wrijving" class="level1">
<h1>Wrijving</h1>
<ol type="1">
<li><p>Statische Coulombwrijving: <span class="math display">F_W \leq \mu_s F_N</span></p></li>
<li><p>Dynamische Coulombwrijving: <span class="math display">F_W = \mu_d F_N</span></p></li>
<li><p>Riemwrijving (Euler–Eytelwein): <span class="math display">F_{1} \leq F_{2} e^{\mu_s \theta}</span></p></li>
<li><p>Rolweerstand: <span class="math display">F_W = \frac{a}{r} F_N</span> Hier is <span class="math inline">a</span> de rolweerstandscoëfficiënt, met een lengte-eenheid, en <span class="math inline">r</span> is de radius van het wiel of de roller.</p></li>
<li><p>Je hebt dus naast je drie vergelijkingen (in 2D) een extra vergelijking. Dus moet er een extra onbekende in je vrijlichaamsdiagram(men) zijn. Vaak is deze onbekende de locatie van <span class="math inline">F_N</span>: deze locatie bepaalt dan of het systeem gaat glijden of kantelen.</p></li>
</ol>
</section>
<section id="geometrisch-centrum" class="level1">
<h1>Geometrisch centrum</h1>
<ol type="1">
<li><p>Twee volumes <span class="math inline">V_1</span> en <span class="math inline">V_2</span> met elk een geometrisch centrum<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> <span class="math inline">\tilde{\overrightharpoon{\mathbf{r}}}_1</span> en <span class="math inline">\tilde{\overrightharpoon{\mathbf{r}}}_2</span>: <span class="math display">V_{tot} = V_1 + V_2</span> <span class="math display">\bar{\overrightharpoon{\mathbf{r}}} = \frac{1}{V_{tot}}\left(\tilde{\overrightharpoon{\mathbf{r}}}_1V_1 + \tilde{\overrightharpoon{\mathbf{r}}}_2V_2\right)</span></p>
<p>Meer volumes: <span class="math display">V_{tot} = \sum_i V_i</span> <span class="math display">\bar{\overrightharpoon{\mathbf{r}}} = \frac{1}{V_{tot}}\sum_i \tilde{\overrightharpoon{\mathbf{r}}}_i V_i</span></p>
<p>Dit kan je gebruiken om het geometrisch centrum te bepalen van een vorm die bestaat uit simpele onderdelen (zoals kubussen, prisma’s, cilinders, en bollen). Je kan ook volumes van elkaar aftrekken, bijvoorbeeld als je een kubus hebt met een cilindrisch gat erin.</p></li>
<li><p>Integreren over oneindig veel kleine volumes <span class="math inline">dV</span>; oftewel het geometrisch centrum bepalen van een arbitraire vorm: <span class="math display">V_{tot} = \int_V dV</span> <span class="math display">\bar{\overrightharpoon{\mathbf{r}}} = \frac{1}{V_{tot}}\int_V \tilde{\overrightharpoon{\mathbf{r}}} dV</span></p></li>
<li><p>Als het gaat om een 2D oppervlak, dan gebruiken we <span class="math inline">A</span> en <span class="math inline">dA</span> in plaats van <span class="math inline">V</span> en <span class="math inline">dV</span>. Als het gaat om een 1D lengte, dan gebruiken we <span class="math inline">L</span> en <span class="math inline">dL</span>.</p></li>
<li><p>Geometrisch centrum <span class="math inline">\bar{x}\hat{\mathbf{i}}+\bar{y}\hat{\mathbf{j}}</span> bepalen van een staaf in de vorm <span class="math inline">y(x)</span> met <span class="math inline">x_0 &lt; x &lt; x_1</span>:</p>
<ol type="1">
<li><p>Neem <span class="math display">dL = \sqrt{(dx)^2+(dy)^2} = \sqrt{1+\left(\frac{dy}{dx}\right)^2} dx</span></p></li>
<li><p>Voor het geometrisch centrum van <span class="math inline">dL</span> geldt <span class="math inline">\tilde{x}= x</span> en <span class="math inline">\tilde{y} = y(x)</span>.</p></li>
<li><p><span class="math display">L = \int_L dL = \int_{x_0}^{x_1}\sqrt{1+\left(\frac{dy}{dx}\right)^2} dx</span></p></li>
<li><p><span class="math display">\bar{x} = \frac{1}{L}\int_L \tilde{x} dL = \frac{1}{L}\int_{x_0}^{x_1} x \sqrt{1+\left(\frac{dy}{dx}\right)^2} dx</span></p>
<p><span class="math display">\bar{y} = \frac{1}{L}\int_L \tilde{y} dL = \frac{1}{L}\int_{x_0}^{x_1} y(x) \sqrt{1+\left(\frac{dy}{dx}\right)^2} dx</span></p></li>
</ol></li>
<li><p>Geometrisch centrum <span class="math inline">\bar{x}\hat{\mathbf{i}}+\bar{y}\hat{\mathbf{j}}</span> bepalen van een oppervlak ingesloten onder een functie <span class="math inline">y(x)</span> met <span class="math inline">x_0 &lt; x &lt; x_1</span>:</p>
<ol type="1">
<li><p>Neem <span class="math inline">dA = y(x) dx</span>.</p></li>
<li><p>Voor het geometrisch centrum van <span class="math inline">dA</span> geldt <span class="math inline">\tilde{x}= x</span> en <span class="math inline">\tilde{y}= y(x)/2</span>.</p></li>
<li><p><span class="math display">A = \int_{x_0}^{x_1} y(x) dx</span></p></li>
<li><p><span class="math display">\bar{x} = \frac{1}{A}\int_A \tilde{x} dA = \frac{1}{A}\int_{x_0}^{x_1} xy(x)dx</span></p>
<p><span class="math display">\bar{y} = \frac{1}{A}\int_A \tilde{y} dA = \frac{1}{A}\int_{x_0}^{x_1} \frac{y(x)}{2}\cdot y(x)dx = \frac{1}{2A}\int_{x_0}^{x_1} y^2(x)dx</span></p></li>
</ol></li>
<li><p>Je kan ook integreren over <span class="math inline">dy</span> in plaats van <span class="math inline">dx</span>, soms is dat makkelijker.</p></li>
<li><p>Bij een cirkel moet je integreren over <span class="math inline">d\theta</span> in plaats van <span class="math inline">dx</span>. Als de oorsprong in het midden van de cirkel ligt, kan je gebruiken:</p>
<p><span class="math display">x = r\cos\theta</span> <span class="math display">y = r\sin\theta</span></p>
<p>Dan, voor alleen de rand van de cirkel: <span class="math display">dL = r d\theta,\quad \tilde{x}=r\cos\theta,\quad \tilde{y}=r\sin\theta</span></p>
<p>Voor het oppervlak van een cirkel (dit kan je vinden door elk partje als een driehoek te benaderen): <span class="math display">dA = \frac{r^2}{2} d\theta,\quad \tilde{x}=\frac{2}{3}r\cos\theta,\quad \tilde{y}=\frac{2}{3}r\sin\theta</span></p></li>
<li><p>Geometrisch centrum <span class="math inline">\bar{x}\hat{\mathbf{i}}+\bar{y}\hat{\mathbf{j}}+\bar{z}\hat{\mathbf{k}}</span> bepalen van een oppervlak ingesloten onder een functie <span class="math inline">z(x, y)</span> met <span class="math inline">x_0 &lt; x &lt; x_1</span> en <span class="math inline">y_0 &lt; y &lt; y_1</span>:</p>
<ol type="1">
<li><p>Neem <span class="math display">dV = z(x, y) dx dy</span></p></li>
<li><p>Voor het geometrisch centrum van <span class="math inline">dA</span> geldt <span class="math inline">\tilde{x}= x</span>, <span class="math inline">\tilde{y}= y</span>, en <span class="math inline">\tilde{z}= z(x,y)/2</span>.</p></li>
<li><p><span class="math display">V = \iint_V dV = \int_{y_0}^{y_1}\int_{x_0}^{x_1}z(x, y) dx dy</span></p></li>
<li><p><span class="math display">\bar{x} = \frac{1}{V}\iint_V \tilde{x}dV = \frac{1}{V} \int_{y_0}^{y_1}\int_{x_0}^{x_1}xz(x, y) dx dy</span> <span class="math display">\bar{y} = \frac{1}{V}\iint_V \tilde{y}dV = \frac{1}{V} \int_{y_0}^{y_1}\int_{x_0}^{x_1}yz(x, y) dx dy</span> <span class="math display">\bar{z} = \frac{1}{V}\iint_V \tilde{z}dV = \frac{1}{V} \int_{y_0}^{y_1}\int_{x_0}^{x_1}\frac{z(x, y)}{2}\cdot z(x, y) dx dy = \frac{1}{2V} \int_{y_0}^{y_1}\int_{x_0}^{x_1} z^2(x, y) dx dy</span></p></li>
</ol></li>
</ol>
</section>
<section id="hydrostatica" class="level1">
<h1>Hydrostatica</h1>
<ol type="1">
<li><p>De druk <span class="math inline">p</span> die een vloeistof uitoefent op zijn omgeving is afhankelijk van de dichtheid <span class="math inline">\rho</span>, de zwaartekrachtsversnelling <span class="math inline">g</span>, en de lokale(!) diepte <span class="math inline">h</span>.</p>
<p><span class="math display">p(h) = \underbrace{\rho g h}_{\text{geeft N/m}^2}</span></p></li>
<li><p>Vaak is het handig om een deel van het water mee te nemen in de systeemgrens. Dan is het gewicht van het water afhankelijk van het getekende oppervlak dat water voorstelt <span class="math inline">A_{water}</span>. Dit geeft een verdeelde belasting, omdat je nu de zwaartekracht neemt per eenheid lengte loodrecht op het vlak van de tekening.</p>
<p><span class="math display">w_{g,water} = \underbrace{A_{water}\rho g}_{\text{geeft N/m}}</span></p></li>
<li><p>Alternatievelijk kan in 3D een lengte <span class="math inline">b</span> loodrecht op het vlak van de tekening gebruikt worden, dan geldt:</p>
<p><span class="math display">w(h) = \underbrace{\rho g h b}_{\text{geeft N/m}}</span></p>
<p><span class="math display">F_{g,water} = \underbrace{V_{water}\rho g = A_{water}b\rho g}_{\text{geeft N}}</span></p></li>
</ol>
</section>
<section id="andere-samenvattingen" class="level1 unnumbered">
<h1 class="unnumbered">Andere samenvattingen</h1>
<p>Disclaimer: de auteur is niet inhoudelijk verantwoordelijk voor deze vakken. Deze teksten kunnen dus fouten bevatten, en aan deze teksten kunnen geen rechten worden ontleend.</p>
<ul>
<li><p>Sterkteleer, <a href="https://www.overleaf.com/read/qqmjnhhxczyp#dbaca1" class="uri">https://www.overleaf.com/read/qqmjnhhxczyp#dbaca1</a></p></li>
<li><p>Dynamica, <a href="https://www.overleaf.com/read/gprmxxxnqtzf#83f127" class="uri">https://www.overleaf.com/read/gprmxxxnqtzf#83f127</a></p></li>
</ul>
</section>
<section id="extra-bewijs-virtuele-arbeid-voor-meerdere-starre-lichamen" class="level1 unnumbered">
<h1 class="unnumbered">Extra: bewijs virtuele arbeid voor meerdere starre lichamen</h1>
<ol type="1">
<li><p>Neem starre lichamen <span class="math inline">i=1, 2,...</span> en op elk lichaam werken externe krachten <span class="math inline">j=1, 2, ...</span> en externe momenten <span class="math inline">k=1, 2,...</span></p></li>
<li><p>Dan is de totale virtuele arbeid: <span class="math display">dU = \sum_i\left( \sum_j\left( \overrightharpoon{\mathbf{F}}_{i,j} \cdot d\overrightharpoon{\mathbf{r}}_{i, j}\right) + \sum_k\left(\overrightharpoon{\mathbf{M}}_{i, k}\cdot d\overrightharpoon{\mathbf{\theta}}_i\right)\right)</span></p></li>
<li><p>Links: de verplaatsing van een elk punt <span class="math inline">d\overrightharpoon{\mathbf{r}}_{i, j}</span> is gelijk aan de verplaatsing van een referentiepunt op dat lichaam <span class="math inline">d\overrightharpoon{\mathbf{r}}_{O_i}</span> plus een rotatieterm <span class="math inline">d\overrightharpoon{\mathbf{\theta}}_i \times \overrightharpoon{\mathbf{r}}_{O_i, j}</span>. Rechts: inproduct is distributief over optellen en alleen de <span class="math inline">\overrightharpoon{\mathbf{M}}</span>-term is afhankelijk van <span class="math inline">k</span>. <span class="math display">dU = \sum_i\left( \sum_j\left( \overrightharpoon{\mathbf{F}}_{i,j} \cdot \left(d\overrightharpoon{\mathbf{r}}_{O_i} + d\overrightharpoon{\mathbf{\theta}}_i \times \overrightharpoon{\mathbf{r}}_{O_i, j}\right)\right) +  \sum_k\overrightharpoon{\mathbf{M}}_{i, k}\cdot d\overrightharpoon{\mathbf{\theta}}_i \right)</span></p></li>
<li><p>Links: inproduct is distributief over optellen. Rechts: inproduct is commutatief. <span class="math display">dU = \sum_i\left( \sum_j\left( \overrightharpoon{\mathbf{F}}_{i,j} \cdot d\overrightharpoon{\mathbf{r}}_{O_i}\right) + \sum_j\left(\overrightharpoon{\mathbf{F}}_{i,j}\cdot \left( d\overrightharpoon{\mathbf{\theta}}_i \times \overrightharpoon{\mathbf{r}}_{O_i, j}\right)\right) +  d\overrightharpoon{\mathbf{\theta}}_i \cdot \sum_k\overrightharpoon{\mathbf{M}}_{i, k}\right)</span></p></li>
<li><p>Links: inproduct is distributief over optellen en alleen de <span class="math inline">\overrightharpoon{\mathbf{F}}</span> term is afhankelijk van <span class="math inline">j</span>. Midden: gebruik <span class="math inline">\overrightharpoon{\mathbf{a}} \cdot (\overrightharpoon{\mathbf{b}} \times \overrightharpoon{\mathbf{c}}) = \overrightharpoon{\mathbf{b}} \cdot (\overrightharpoon{\mathbf{c}} \times \overrightharpoon{\mathbf{a}})</span>. <span class="math display">dU = \sum_i\left( \sum_j\overrightharpoon{\mathbf{F}}_{i,j} \cdot d\overrightharpoon{\mathbf{r}}_{O_i} + \sum_j\left( d\overrightharpoon{\mathbf{\theta}}_i\cdot \left(\overrightharpoon{\mathbf{r}}_{O_i, j} \times \overrightharpoon{\mathbf{F}}_{i,j}\right)\right)+ d\overrightharpoon{\mathbf{\theta}}_i \cdot \sum_k\overrightharpoon{\mathbf{M}}_{i, k}\right)</span></p></li>
<li><p>Links: <span class="math inline">\sum_j\overrightharpoon{\mathbf{F}}_{i,j}</span> is de som van krachten op één lichaam, dus gelijk aan <span class="math inline">\overrightharpoon{\mathbf{0}}</span>. Midden: inproduct is distributief over optellen, en <span class="math inline">d\overrightharpoon{\mathbf{\theta}}_i</span> is onafhankelijk van <span class="math inline">\hat{\mathbf{j}}</span>. <span class="math display">dU = \sum_i\left( \overrightharpoon{\mathbf{0}} \cdot d\overrightharpoon{\mathbf{r}}_{O_i} +  d\overrightharpoon{\mathbf{\theta}}_i\cdot \sum_j\left(\overrightharpoon{\mathbf{r}}_{O_i, j} \times \overrightharpoon{\mathbf{F}}_{i,j}\right)+ d\overrightharpoon{\mathbf{\theta}}_i \cdot \sum_k\overrightharpoon{\mathbf{M}}_{i, k}\right)</span></p></li>
<li><p>Links: inproduct geeft 0. Rechts: inproduct is distributief over optellen. <span class="math display">dU = \sum_i\left( 0 +  d\overrightharpoon{\mathbf{\theta}}_i\cdot \left(\sum_j\left(\overrightharpoon{\mathbf{r}}_{O_i, j} \times \overrightharpoon{\mathbf{F}}_{i,j}\right)+  \sum_k\overrightharpoon{\mathbf{M}}_{i, k}\right)\right)</span></p></li>
<li><p>Rechterterm is de som van momenten op één lichaam, en dat is gelijk aan <span class="math inline">\overrightharpoon{\mathbf{0}}</span>. <span class="math display">dU = \sum_i\left(  d\overrightharpoon{\mathbf{\theta}}_i\cdot \overrightharpoon{\mathbf{0}}\right) = \sum_i 0 = 0</span></p></li>
</ol>
</section>
<section id="interne-richtlijnen-tentaminering" class="level1 unnumbered">
<h1 class="unnumbered">Interne richtlijnen tentaminering</h1>
<ol type="1">
<li><p>De tentaminering bestaat uit een Tussentoets <span class="math inline">TT</span>, een Tentamen <span class="math inline">T</span> met een Tentamen Extra Opgave <span class="math inline">TEO</span>, een Hertentamen <span class="math inline">H</span> met een Hentamen Extra Opgave <span class="math inline">HEO</span>, en een eventuele Bonusregeling <span class="math inline">B</span>.</p></li>
<li><p>Het eindcijfer <span class="math inline">C</span> wordt als volgt berekend. <span class="math display">C = \min\left(\frac{1}{10}\max(TT, TEO, HEO) + \frac{9}{10}\max(T, H) + B, 10\right)</span></p></li>
<li><p>Deelcijfers worden tussendoor afgerond op 0.1, volgens de TU-richtlijnen.</p></li>
<li><p>Let op: deelcijfers tellen alleen mee als je een 5.0 of hoger haalt. Anders tellen ze door in de berekening als 0.</p></li>
<li><p>Deelcijfers worden als volgt berekend.</p>
<p><span class="math display">\frac{\text{behaalde punten}}{(\text{maximaal te behalen punten}) - (\text{eventuele normering})}\cdot9+1</span></p></li>
<li><p>TT bevat in principe vier vragen:</p>
<ol type="1">
<li><p>Leerdoel 1 (vectoren)</p></li>
<li><p>Leerdoelen 2, 3 en/of 4 (evenwicht in 2D, inclusief systeemvorming en diagram tekenen)</p></li>
<li><p>Leerdoelen 2, 3 en/of 4 (evenwicht in 3D, inclusief systeemvorming en diagram tekenen)</p></li>
<li><p>Leerdoelen 5 en/of 6 (resulterende kracht en werklijn)</p></li>
</ol></li>
<li><p>T en H bevatten in principe zes vragen:</p>
<ol type="1">
<li><p>Leerdoel 1 (vectoren)</p></li>
<li><p>Leerdoelen 2, 3, 4, 7, en/of 8 (vakwerken, frames, en/of machines)</p></li>
<li><p>Leerdoelen 9 en/of 10 (inwendige belasting en/of V- en M-lijn)</p></li>
<li><p>Leerdoelen 11 en/of 12 (virtuele arbeid en/of potentiële energie)</p></li>
<li><p>Leerdoelen 2, 3, 4, en/of 14 (wrijving)</p></li>
<li><p>Leerdoelen 13 en/of 15 (geometrisch centrum en/of hydrostatica)</p></li>
</ol>
<p>Elk leerdoel, en elke denk- en rekenstap binnen elke methode, wordt niet meer dan éénmaal getoetst, tenzij het Tussentoetsstof is (Leerdoelen 1 t/m 6).</p></li>
<li><p>Het aantal te behalen punten wordt gegeven per deelvraag.</p></li>
<li><p>Deelvragen zijn onafhankelijk van elkaar. Binnen één deelvraag kan om meerdere resultaten gevraagd worden, die wel afhankelijk van elkaar zijn. Elk gevraagd resultaat is dikgedrukt.</p></li>
<li><p>TEO en HEO bestaan elk uit één vraag uit TT.</p></li>
<li><p>TT heeft in principe 27 maximaal te behalen punten. T en H hebben elk 36 maximaal te behalen punten. TEO en HEO hebben elk 9 maximaal te behalen punten. Dit is een cijferresolutie van 1/3, 1/4, respectievelijk 1.</p></li>
<li><p>Elk punt is één denk- of rekenstap. Voor elke gemaakte denk- of rekenfout kan een student maximaal één punt verliezen. In andere woorden: er wordt rekening gehouden met doorrekenfouten. Dit geldt niet, als een fout de uitwerking zodanig versimpeld, dat aan andere denk- of rekenstappen niet meer toegekomen wordt.</p></li>
<li><p>De normering bestaat uitsluitend uit het aantal punten, waarbij niet aan de richtlijnen is voldaan, voornamelijk betreft leerdoelen, deelvragen, punten, en denk- en rekenstappen. Als een normering wordt toegepast, is dat niet om een bepaald slagingspercentage te behalen.</p></li>
<li><p>De normering en de onderbouwing worden gepubliceerd als Announcement en als errata bij Oude Tentamens.</p></li>
</ol>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Dit krijg je bij Dynamica<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Dus niet alleen situaties waar er geen snelheid is. Sterker nog, Statica kan eigenlijk ook gebruikt worden als er een constante versnelling is, want dat kan je behandelen als een soort extra zwaartekracht.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Zie <a href="#moment" data-reference-type="ref+label" data-reference="moment">9</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Alternatievelijk kan je ook een onbekende grootte en een onbekende richting (hoek) tekenen: <span class="math inline">F_A</span> en <span class="math inline">\theta_A</span>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Zie <a href="#res" data-reference-type="ref+label" data-reference="res">10</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Hibbeler gebruik een streepje (<span class="math inline">\bar{x}</span>) om een de positie van de werklijn aan te geven. Dit doen wij ook, maar let dus op: het is een streepje en geen pijl, dus het is een scalar, geen vector!<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Oefentip: toon dit aan.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Er kan een onbekende minder zijn: dan heeft het systeem een vrijheidsgraad. Het komt vaak voor dat een staaf om zijn eigen as kan draaien, wat verder geen invloed heeft op het systeem. In dit geval heb je dus maar vijf onbekenden en valt er dus een vergelijking weg (die geeft geen extra informatie).<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Oefentip: toon dit aan.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>De laatste term wordt behandeld in dynamica en is nu dus nog niet belangrijk. <span class="math inline">I</span> is het draai-equivalent van massa (het ‘traagheidsmoment’), en <span class="math inline">\alpha</span> is het draai-equivalent van versnelling (hoekversnelling, rad/s<span class="math inline">^2</span>). Deze vergelijking is dus het draai-equivalent van de derde wet van Newton.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>Oefentip: toon dit aan.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>Zie collegeslides.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>Zie de laatste pagina voor een bewijs.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>In document gebruiken we in plaats van <span class="math inline">\partial</span> en <span class="math inline">\delta</span> gewoon een <span class="math inline">d</span> (“abuse of notation”).<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>Als er momenten op meerdere lichamen werken, vind dan ook de virtuele rotaties <span class="math inline">d
    \overrightharpoon{\mathbf{\theta}}_j</span>.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>De reden is als volgt: als op een systeem alleen conservatieve krachten werken, is de verrichte arbeid <span class="math inline">dU</span> op het systeem gelijk aan de verloren potentiële energie van het systeem <span class="math inline">dV</span>. We hebben al gezien dat voor een systeem in evenwicht <span class="math inline">dU=0</span>, dus <span class="math inline">dV=0</span>. Dus voor elke vrijheidsgraad <span class="math inline">q</span> die invloed heeft op <span class="math inline">V</span>, moet gelden <span class="math inline">dV/dq=0</span>.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>Want <span class="math inline">d^2V/dq^2&lt;0</span> zou betekenen: als je iets van het evenwichtspunt af gaat zitten, wordt <span class="math inline">V</span> minder. In een systeem waaarop alleen conservatieve krachten werken, is er dus potentiële energie omgezet in kinetische energie. De beweging zal dus versnellen.<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>Vanaf hier gebruiken we ook tildes (<span class="math inline">\tilde{x}</span>) om het geometrisch centrum aan te geven van een onderdeel; het streepje (<span class="math inline">\bar{x}</span>) geeft het geometrisch centrum aan van het geheel. Dit streepje wordt in de wiskunde gebruikt om een gemiddelde aan te geven. Zowel het geometrisch centrum als de werklijn van een resultante kracht, zijn ook eigenlijk gewoon een gewogen gemiddelde, vandaar dat we deze notatie gebruiken.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>