<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>samenvatting – Website</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dc55a5b9e770e841cd82e46aadbfb9b0.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Website</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<p>{ “cells”: [ { “cell_type”: “markdown”, “metadata”: {}, “source”: [ “\documentclass{article}”, “”, “\usepackage[dutch]{babel}”, “\usepackage{datetime2}”, “\usepackage{hyperref}”, “\usepackage[a4paper]{geometry}”, “\setlength{\parindent}{0pt}”, “”, “\usepackage{amsmath}”, “\usepackage{amssymb}”, “\usepackage{amsfonts}”, “\usepackage[allcommands]{overarrows}”, “\usepackage{bm}”, “”, “\renewcommand{\v}[1]{\overrightharpoonup{\bm{#1}}}”, “\renewcommand{\u}[1]{\hat{\bm{#1}}}”, “\newcommand{\F}{\v{F}}”, “\newcommand{\M}{\v{M}}”, “\renewcommand{\r}{\v{r}}”, “\renewcommand{\i}{\hat{\bm{\imath}}}”, “\renewcommand{\j}{\hat{\bm{\jmath}}}”, “\renewcommand{\k}{\u{k}}”, “”, “\title{Samenvatting Statica}”, “\author{Domas Syaifoel}”, “\date{Versie \DTMnow \\ Deze tekst valt onder de CC BY-NC 4.0 licentie\footnote{\url{http://creativecommons.org/licenses/by-nc/4.0/}}}”, “”, “\begin{document}”, “”, “\maketitle”, “”, “”, “\section{Statica in een notendop}”, “”, “De derde wet van Newton is:”, “<span class="math display">\[\\sum\\F = m\\v{a}\]</span>”, “Daarnaast is er een draai-equivalent van de derde wet van Newton\footnote{Dit krijg je bij Dynamica}:”, “<span class="math display">\[\\sum\\M_G = I_G\\v{\\alpha}\]</span>”, “De som van momenten berekenen we als volgt:”, “<span class="math display">\[\\sum\\M_G = \\sum_i \\r_{Gi}\\times \\F_i + \\sum_j \\M_{ext, j}\]</span>”, “Het vak Statica behandelt de situaties waar er geen versnelling is\footnote{Dus niet alleen situaties waar er geen snelheid is. Sterker nog, Statica kan eigenlijk ook gebruikt worden als er een constante versnelling is, want dat kan je behandelen als een soort extra zwaartekracht.}:”, “<span class="math display">\[\\sum\\F = \\v{0}\]</span>”, “<span class="math display">\[\\sum_i \\r_{Gi}\\times \\F_i + \\sum_j \\M_{ext, j}= \\v{0}\]</span>”, “Alternatievelijk geldt voor evenwicht:”, “\begin{enumerate}”, ” \item Virtuele arbeid is nul. “,” <span class="math display">\[dU = \\sum_i d\\v{r}_i\\cdot\\F_i = 0\]</span>“,” \item De afgeleide van de potenti\"ele energie is nul.“,” <span class="math display">\[\\frac{d}{dq}V = \\frac{d}{dq}\\left(\\sum_i m_igh_i(q) + \\sum_j\\frac{1}{2}k_js_j^2(q)\\right)=0\]</span>“,”\end{enumerate}“,”“,”Wat betekent dit allemaal? Wat zijn die pijltjes en dikgedrukte letters? Wat is een moment? Wat is het verschil tussen vermenigvuldigen met een puntje en vermenigvuldigen met een kruisje? Wat is virtuele arbeid? Wat zijn die grote E’s met letters eronder?“,”“,”Dat staat allemaal in de rest van dit document (en leggen we je graag verder uit tijdens de hoor- en werkcolleges).“,”\tableofcontents“,”“,”“,”\newpage“,”\section{Leerdoelen}“,”Aan het eind van dit vak zou de student het volgende moeten kunnen:“,”\begin{enumerate}“,”\item Het toepassen van de volgende \textbf{vectoroperaties} op wiskundige vraagstukken: optellen, aftrekken, scalair vermenigvuldigen, magnitude bepalen, normaliseren, inproduct, uitproduct, component bepalen, projecteren, onderlinge hoek bepalen; en op natuurkundige vraagstukken: arbeid bepalen gegeven een constante krachtvector en verplaatsing, momentvector bepalen gegeven een krachtvector en positievectoren, moment langs een as bepalen gegeven een momentvector en positievectoren.“,”\item Een \textbf{systeem modelleren} als één of meer puntdeeltjes of starre lichamen, of een combinatie daarvan, in zowel 2D als 3D.“,”\item \textbf{Vrijlichaamsdiagrammen} tekenen van één of meer puntdeeltjes of starre lichamen, of een combinatie daarvan, in zowel 2D als 3D.“,”\item Evenwichtsvoorwaarden bepalen van één of meer puntdeeltjes of starre lichamen, of een combinatie daarvan, door middel van de \textbf{vectormethode}, in zowel 2D als 3D.“,”\item De \textbf{resulterende kracht} bepalen van twee of meer krachten, en de \textbf{werklijn} van de resulterende kracht bepalen, in zowel 2D als 3D. In 3D alleen als alle krachten parallel lopen.“,”\item De resulterende kracht en de werklijn daarvan bepalen van één of meer \textbf{verdeelde belastingen}, door middel van zowel de \textbf{superpositiemethode} als de \textbf{integratiemethode}.“,”\item Evenwichtsvoorwaarden bepalen van een gegeven \textbf{vakwerk}, door middel van zowel de \textbf{knooppuntmethode} als de \textbf{snedemethode}, in zowel 2D als 3D.“,”\item \textbf{Nulstaven} (zero force members) en \textbf{tweekrachtsstaven} (two force members) identificeren, en daarmee vrijlichaamsdiagrammen versimpelen.“,”\item De \textbf{inwendige belasting} bepalen, namelijk normaalkracht, schuifkracht, en buigmoment, op gegeven posities van een gegeven 2D balk.“,”\item \textbf{Schuifkracht- en buigmomentdiagrammen} tekenen van een gegeven 2D balk.“,”\item Evenwichtsvoorwaarden bepalen van één of meer starre lichamen waarop \textbf{Coulombwrijving}, \textbf{riemwrijving}, \textbf{rolweerstand}, of een combinatie daarvan, van toepassing is.“,”\item Evenwichtsvoorwaarden bepalen van mechanismen in 2D, door middel van de \textbf{virtuele arbeidmethode} en de \textbf{potentiële energiemethode}.“,”\item \textbf{Stabiliteit} bepalen van een evenwichtssituatie van een mechanisme in 2D, door middel van de \textbf{potentiële energiemethode}.“,”“,”\item Het \textbf{geometrisch centrum} bepalen van curvesegmenten, oppervlakken, en volumes, door middel van zowel \textbf{superpositie} als de \textbf{integratiemethode}.“,”\item Evenwichtsvoorwaarden bepalen van één of meer starre lichamen waarop \textbf{hydrostatische belasting} van toepassing is.“,”\end{enumerate}“,”“,”\newpage“,”\section{Vectoren}“,”“,”Notatie: het is gebruikelijk dat vectoren getypt dikgedrukt zijn (<span class="math inline">\(\\bm{r}\)</span>). Handgeschreven is het gebruikelijk om ze aan te duiden met een pijl erboven <span class="math inline">\(\\overrightharpoonup{r}\)</span> (of alternatievelijk <span class="math inline">\(\\overbar{r}\)</span> of <span class="math inline">\(\\underbar{r}\)</span>). In dit document gebruiken we zowel dikgedrukt als een halve pijl erboven (<span class="math inline">\(\\v{r}\)</span>). Vectoren met lengte 1 noteren we dikgedrukt met een dakje (<span class="math inline">\(\\u{u}\)</span>).“,”“,”“,”Basis-eenheidsvectoren:“,”<span class="math display">\[ \\i = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\j = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad \\k = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\]</span>“,”“,”Notatie met basisvectoren:“,”<span class="math display">\[ \\v{r} = \\begin{pmatrix} a \\\\ b \\\\ c \\end{pmatrix}=a\\i+b\\j+c\\k, \\quad \\v{s} = d\\i + e\\j + f\\k\]</span> “,”“,”Optellen:“,”<span class="math display">\[ \\v{r} + \\v{s} = (a+d)\\i + (b+e)\\j + (c+f)\\k  \]</span>“,”“,”Scalair vermenigvuldigen:“,”<span class="math display">\[ g\\v{r} = ga\\i + gb\\j + gc\\k\]</span>“,”“,”Aftrekken:“,”<span class="math display">\[ \\v{r} - \\v{s} = \\v{r} + (-1)\\v{s} \]</span>“,”“,”Positievectoren:“,”<span class="math display">\[\\r_{O B} = \\r_{O A} + \\r_{A B}\]</span>“,”<span class="math display">\[\\r_{A B} = \\r_{O B} - \\r_{O A}\]</span>“,”“,”Magnitude:“,”<span class="math display">\[r = ||\\v{r}|| = \\sqrt{a^2+b^2+c^2}\\quad\\leftarrow\\text{Zorg dat er altijd duidelijk onderscheid is tussen $r$ en $\\v{r}$}\]</span>“,”“,”Eenheidsvector (normalizeren):“,”<span class="math display">\[\\u{u}_r = \\frac{1}{r}\\v{r}\]</span>“,”“,”\section{Krachtvectoren}“,”“,”Algemene splitsing in grootte en richting:“,”<span class="math display">\[\\v{F}=F\\u{u}_F\]</span>“,”“,”In 2D als je een hoek <span class="math inline">\(\\theta\)</span> hebt vanaf de positieve x-as linksom:“,”<span class="math display">\[\\v{F}=F(\\u{i}\\cos\\theta +\\u{j}\\sin\\theta)\]</span>“,”“,”\section{Inproduct}“,”Inproduct:“,”<span class="math display">\[ \\v{r} \\cdot \\v{s}= ad+be+cf \\quad\\leftarrow\\text{Dit is dus een scalar!}\]</span>“,”Met een hoek <span class="math inline">\(\\theta\)</span> tussen <span class="math inline">\(\\v{r}\)</span> en <span class="math inline">\(\\v{s}\)</span>:“,”<span class="math display">\[ \\v{r} \\cdot \\v{s}= rs\\cos\\theta \]</span>“,”“,”Scalaire component van <span class="math inline">\(\\v{r}\)</span> langs <span class="math inline">\(\\v{s}\)</span>:“,”<span class="math display">\[\\text{comp} _s(\\v{r})=\\v{r}\\cdot\\u{u}_s\\quad\\leftarrow\\text{Dit is dus een scalar!}\]</span>“,”“,”Projectie(vector) van <span class="math inline">\(\\v{r}\)</span> op <span class="math inline">\(\\v{s}\)</span>:“,”<span class="math display">\[\\v{\\text{proj}} _s(\\v{r})=\\text{comp} _s(\\v{r})\\u{u}_s\\quad\\leftarrow\\text{Dit is dus een vector!}\]</span>“,”“,”Arbeid van een constante kracht:“,”<span class="math display">\[U = \\v{F}\\cdot \\v{\\Delta r}\]</span>“,”“,”Infinitesimale arbeid:“,”<span class="math display">\[dU = \\v{F}\\cdot\\v{d r} \]</span>“,”“,”Algemene arbeid (over een pad <span class="math inline">\(C\)</span>):“,”<span class="math display">\[U=\\int_C\\v{F}\\cdot\\v{d r}\]</span>“,”“,”\section{Vrijlichaamsdiagram}“,”Een vrijlichaamsdiagram (<code>free body diagram'', FBD) bevat het volgende.\n",         "\n",         "\\begin{enumerate}\n",         "    \\item Het lichaam naar keuze, en \\textbf{niet} de omgeving. \n",         "    \n",         "    Teken de systeemgrens zodanig dat de krachten die je wilt bepalen, op de systeemgrens werken. Bijvoorbeeld: als je de kracht wil bepalen die de grond op een wiel uitoefent, moet je systeemgrens door dat contactpunt heen lopen.\n",         "\n",         "    \\item Alle (aangrijpings)punten waarop krachten werken.\n",         "\n",         "    \\item Alle krachten en externe (koppel)momenten\\footnote{Zie \\autoref{moment}} die op het lichaam werken.\n",         "\n",         "    Let op: teken de krachten die de omgeving op het lichaam uitoefent (dus niet de tegenovergestelde krachten die het lichaam op de omgeving uitoefent).\n",         "\n",         "    Als een kracht een bekende richting heeft, teken je één kracht met een onbekende grootte, en geef je die grootte een naam (bijvoorbeeld $A_x$).\n",         "\n",         "    Als een kracht ook geen bekende richting hebt, moet je dus twee onbekenden hebben. Bijvoorbeeld twee krachten met bekende richtingen, loodrecht op elkaar, en met twee onbekende groottes ($A_x$ en $A_y$).\\footnote{Alternatievelijk kan je ook een onbekende grootte en een onbekende richting (hoek) tekenen: $F_A$ en $\\theta_A$.}\n",         "\n",         "    Als er op een lichaam een verdeelde belasting werkt, raad ik aan om die alvast te vervangen door een puntbelasting (met de juiste werklijn), voordat je je vrijlichaamsdiagram tekent\\footnote{Zie \\autoref{res}}.\n",         "\n",         "    \\item Alle afstanden die invloed hebben op het momentevenwicht.\n",         "\n",         "    Bijvoorbeeld afstanden tussen krachten en afstanden vanaf het zwaartepunt.\n",         "\n",         "    \\item Een assenstelsel.\n",         "\\end{enumerate}\n",         "\n",         "Een vrijlichaamsdiagram zou alle informatie moeten bevatten die je nodig hebt om een probleem op te lossen, en geen informatie die je niet nodig hebt.\n",         "\n",         "\\section{Krachtenevenwicht puntdeeltje}\n",         "\n",         "\\begin{enumerate}\n",         "    \\item Teken een vrijlichaamsdiagram. Dit is de belangrijkste stap.\n",         "    \\item Check of alle krachten door één punt gaan.\n",         "    \\item Check of er twee onbekenden zijn in 2D, of drie onbekenden in 3D. Voorbeeld: onbekenden $F_1, F_2, F_3$.\n",         "    \\item Voorbeeld: $F_4$ bekend. Dan:\n",         "\n",         "    $$ \\sum\\F = \\v{0} = \\F_1 + \\F_2 + \\F_3 + \\F_4$$\n",         "\n",         "    \\item Elke kracht omschrijven als een eenheidsvector keer een grootte:\n",         "    $$\\sum\\F  = \\u{u}_1F_1 + \\u{u}_2F_2 + \\u{u}_3F_3 + \\u{u}_4F_4$$\n",         "\n",         "    \\item Opdelen in componenten:\n",         "\n",         "    $$ (\\u{u}_1\\cdot\\i) F_1 + (\\u{u}_2\\cdot\\i) F_2 + (\\u{u}_3\\cdot\\i) F_3 + (\\u{u}_4\\cdot\\i) F_4 = 0$$\n",         "\n",         "    $$ (\\u{u}_1\\cdot\\j) F_1 + (\\u{u}_2\\cdot\\j) F_2 + (\\u{u}_3\\cdot\\j) F_3 + (\\u{u}_4\\cdot\\j) F_4 = 0$$\n",         "\n",         "    $$ (\\u{u}_1\\cdot\\k) F_1 + (\\u{u}_2\\cdot\\k) F_2 + (\\u{u}_3\\cdot\\k) F_3 + (\\u{u}_4\\cdot\\k) F_4 = 0$$\n",         "\n",         "    \\item Dit stelsel van drie vergelijkingen en drie onbekenden oplossen (twee in 2D).\n",         "    \\item Controleer de eenheid van je (symbolische) eindantwoord(en).\n",         "\\end{enumerate}\n",         "\n",         "\\section{Uitproduct}\n",         "Het uitproduct is niet hetzelfde als het inproduct!\n",         "$$ \\v{r} \\times \\v{s}= (bf-ce)\\i + (cd-af)\\j+ (ae-bd)\\k \\quad\\leftarrow\\text{Dit is dus een vector!}$$\n",         "$$\\v{r} \\times \\v{s} = -(\\v{s} \\times \\v{r}) \\quad\\leftarrow\\text{Je kan een uitproduct dus niet zomaar omdraaien!}$$\n",         "$$||\\v{r}\\times\\v{s}||=rs\\sin\\theta$$\n",         "\n",         "Er zijn dus in totaal drie manieren om een vector te</code>vermenigvuldigen’‘: “,”\begin{enumerate}“,” \item Scalair product: <span class="math inline">\(s(a\\i+b\\j+c\\k) = sa\\i + sb\\j +sc\\k\)</span>“,” \item Inproduct: <span class="math inline">\((a\\i+b\\j+c\\k)\\cdot(d\\i+e\\j+f\\k)=ad+be+cf\)</span>“,” \item Uitproduct: <span class="math inline">\((a\\i+b\\j+c\\k)\\times(d\\i+e\\j+f\\k)=(bf-ce)\\i+(cd-af)\\j+(ae-bd)\\k\)</span>“,”\end{enumerate}“,”Let op de drie verschillende notaties die we hier dus voor gebruiken.“,”“,”\section{Moment}“,”\label{moment}“,”“,”\begin{enumerate} “,”“,”\item Een moment is het draai-equivalent van een kracht. Een moment is een vector, want een moment heeft een grootte en een richting.“,”“,”\item Een momentvector loopt parallel aan de as, waaromheen dit moment een draaiing zou veroorzaken.“,”“,”\item De richting van een momentvector wordt bepaald met de \textbf{rechterhandregel}: als je met je rechterhand de momentvector vast zou grijpen, zodat je vingers wijzen in de richting van de draaiing, staat je duim in de richting van de pijlpunt.“,”“,”\item Het moment dat een kracht <span class="math inline">\(\\F_B\)</span> levert om een punt <span class="math inline">\(A\)</span>:“,”<span class="math display">\[\\M_A = \\r_{A B} \\times \\F_B\]</span>“,”“,”\item De component van het moment dat een kracht <span class="math inline">\(\\F_B\)</span> levert langs een as <span class="math inline">\(CD\)</span>:“,”<span class="math display">\[M_{CD} = \\text{comp}_{CD}(\\M_E) = \\M_E\\cdot \\u{u}_{C D}=(\\r_{EB} \\times \\F_B)\\cdot \\u{u}_{C D}\]</span> “,”“,”Hierbij is <span class="math inline">\(E\)</span> een willekeurig punt op de lijn <span class="math inline">\(CD\)</span>, dus het kan ook <span class="math inline">\(C\)</span> of <span class="math inline">\(D\)</span> zelf zijn. Verder is <span class="math inline">\(M_{CD}\)</span> de component in de richting van <span class="math inline">\(\\u{u}_{CD}\)</span>. Dit is dus negatief als de draaiing in de andere richting is: als je de grootte wilt hebben, moet je dus nog de absolute waarde nemen.“,”\end{enumerate}“,”“,”\section{Resulterende kracht}“,”\label{res}“,”“,”\begin{enumerate}“,”\item Algemeen:“,”Grootte en richting:“,”<span class="math display">\[\\F_{res} = \\F_A + \\F_B\]</span>“,”“,”<span class="math inline">\(\\F_{res}\)</span> grijpt aan op punt <span class="math inline">\(C\)</span> als voor elk willekeurig punt <span class="math inline">\(D\)</span> geldt:“,”<span class="math display">\[\\r_{D C}\\times\\F_{res} = \\r_{D A}\\times\\F_A + \\r_{D B}\\times\\F_B\]</span> “,”“,”Er zijn oneindig veel mogelijke punten <span class="math inline">\(C\)</span>, dit is namelijk de werklijn van <span class="math inline">\(\\F_{res}\)</span>.“,”“,”Voor meer krachten (<span class="math inline">\(i\)</span> is hier een sommatie-index, dus niet de eenheidsvector):“,”<span class="math display">\[\\F_{res} = \\sum_i\\F_i\]</span>“,”“,”<span class="math inline">\(\\F_{res}\)</span> grijpt aan op punt <span class="math inline">\(C\)</span> als voor elk willekeurig punt <span class="math inline">\(D\)</span> geldt:“,”<span class="math display">\[\\r_{D C}\\times\\F_{res} = \\sum_i \\r_{D i}\\times\\F_i\]</span> “,”“,”Opnieuw: er zijn oneindig veel mogelijke punten <span class="math inline">\(C\)</span>, dit is namelijk de werklijn van <span class="math inline">\(\\F_{res}\)</span>.“,”“,”\item Voor parallele krachten in 2D, elk in <span class="math inline">\(y\)</span>-richting:“,”<span class="math display">\[F_{res} = F_A + F_B\]</span>“,”“,”Werklijn\footnote{Hibbeler gebruik een streepje (<span class="math inline">\(\\bar{x}\)</span>) om een de positie van de werklijn aan te geven. Dit doen wij ook, maar let dus op: het is een streepje en geen pijl, dus het is een scalar, geen vector!} van <span class="math inline">\(F_{res}\)</span>:“,”<span class="math display">\[\\bar{x} = \\frac{1}{F_{res}}(x_AF_A+x_BF_B)\]</span>“,”“,”Voor meer parallele krachten:“,”<span class="math display">\[F_{res} = \\sum_i F_i\]</span>“,”“,”Werklijn van <span class="math inline">\(F_{res}\)</span>:“,”<span class="math display">\[\\bar{x} = \\frac{1}{F_{res}}\\sum_i \\tilde{x}_i F_i\]</span>“,”“,”\item Voor een verdeelde belasting <span class="math inline">\(w(x)\)</span> met <span class="math inline">\(x_0 &lt; x &lt; x_1\)</span>:“,”<span class="math display">\[F_{res} = \\int_{x_0}^{x_1} w(x) dx\]</span>“,”<span class="math display">\[\\bar{x} = \\frac{1}{F_{res}}\\int_{x_0}^{x_1} xw(x)dx\]</span>“,”“,”\item Voor <span class="math inline">\(w(x)=ax^b\)</span>, met een constante <span class="math inline">\(a\)</span> en <span class="math inline">\(b\)</span>, en <span class="math inline">\(0&lt;x&lt;l\)</span>, geldt\footnote{Oefentip: toon dit aan.}:“,”<span class="math display">\[\\bar{x} = \\frac{b+1}{b+2}l\]</span>“,”“,”Voor een constante <span class="math inline">\(w\)</span>, dus <span class="math inline">\(w(x) = w = wx^0\)</span>, geldt <span class="math inline">\(b=0\)</span> dus <span class="math inline">\(\\bar{x} = \\frac{1}{2}l\)</span>.“,”“,”Voor een lineair oplopende <span class="math inline">\(w(x) = w_{max}\\frac{x}{l} = \\frac{w_{max}}{l}x^1\)</span> geldt <span class="math inline">\(b=1\)</span> dus <span class="math inline">\(\\bar{x} = \\frac{2}{3}l\)</span>.“,”“,”\end{enumerate}“,”“,”\section{Evenwicht star lichaam}“,”“,”\begin{enumerate}“,” \item Teken een vrijlichaamsdiagram.“,” \item Check of er drie onbekenden zijn in 2D, en zes onbekenden in 3D\footnote{Er kan een onbekende minder zijn: dan heeft het systeem een vrijheidsgraad. Het komt vaak voor dat een staaf om zijn eigen as kan draaien, wat verder geen invloed heeft op het systeem. In dit geval heb je dus maar vijf onbekenden en valt er dus een vergelijking weg (die geeft geen extra informatie).}.“,” \item Voorbeeld: onbekenden <span class="math inline">\(F_{Ax}, F_{Ay}, F_{Az}, M_{Ax}, M_{Ay}, M_{Az}\)</span> op punt <span class="math inline">\(A\)</span>, en bekenden “,” “,” <span class="math inline">\(\\F_B,\\F_C,\\M_B,\\M_C\)</span>, op punten <span class="math inline">\(B\)</span> en <span class="math inline">\(C\)</span>.“,” \item Krachtenevenwicht opstellen:“,” <span class="math display">\[\\sum\\F = \\v{0} = F_{A,x}\\i + F_{A,y}\\j + F_{A,z}\\k + \\F_B + \\F_C \]</span>“,”“,” \item Elke kracht omschrijven naar een eenheidsvector keer een grootte.“,”“,” \item Dit opdelen in componenten zodat je drie scalaire vergelijkingen overhoudt (in 3D).“,”“,” \item Momentevenwicht opstellen om een handig punt, in dit geval punt <span class="math inline">\(A\)</span>:“,” <span class="math display">\[\\sum \\M_A = \\v{0} = \\underbrace{\\sum_i\\M_{ext, i}}_{\\text{externe momenten}} + \\underbrace{\\sum_{j} \\r_{A,j} \\times \\F_j}_{\\text{momenten door externe krachten}} \]</span>“,”“,” Hier zijn <span class="math inline">\(i\)</span> en <span class="math inline">\(j\)</span> weer een sommatie-indices, in dit voorbeeld:“,” <span class="math display">\[\\sum \\M_A = \\v{0} = M_{Ax}\\i+ M_{Ay}\\j +M_{Az}\\k+\\M_B + \\M_C + \\r_{A B} \\times \\F_B + \\r_{A C} \\times \\F_C \]</span>“,”“,” \item Hier weer elke kracht omschrijven naar een eenheidsvector keer een grootte.“,”“,” \item Uitproducten uitschrijven.“,”“,” \item Resultaat weer opdelen in componenten zodat je drie extra scalaire vergelijkingen overhoudt (in 3D).“,” \item In totaal heb je dan zes scalaire vergelijkingen en zes onbekenden. Dit kan je dus oplossen.“,” \item Controleer de eenheid van je (symbolische) eindantwoord(en).“,”\end{enumerate}“,”“,”\section{Vaste, gebonden, en vrije vectoren}“,”\begin{enumerate}“,”“,”\item Een \textbf{vaste vector} (<code>fixed vector'') verliest zijn betekenis als hij getransleerd wordt. Voorbeelden: positievector van een puntdeeltje; positievector/snelheidsvector/versnellingsvector van een star lichaam; krachtvector als stabiliteit van belang is.\n",         "\n",         "\\item Een \\textbf{gebonden vector} (</code>sliding vector’‘) kan over zijn werklijn verschoven worden. Voorbeelden: krachtvector als stabiliteit niet van belang is; moment ten gevolge van kracht.“,”“,”\item Twee tegengestelde maar even grote krachten <span class="math inline">\(F\)</span> met onderlinge afstand <span class="math inline">\(d\)</span> kunnen vervangen worden door een extern moment met grootte <span class="math inline">\(M=Fd\)</span>. Dit heet een \textbf{koppel}. Hiervan maakt de locatie en de richting van de krachten niet uit; alleen de onderlinge afstand en de richting van het resultante moment\footnote{Oefentip: toon dit aan.}. Dit betekent dat zo’n moment een \textbf{vrije vector} (<code>free vector'') is: alleen de richting en grootte zijn van belang; niet de locatie. Meer voorbeelden van een vrije vector: extern moment; moment ten gevolge van koppel; snelheid en versnelling van een puntdeeltje; hoekpositievector/hoeksnelheidsvector/hoekversnellingsvector van een star lichaam.\n",         "\n",         "\\item Voor momentevenwicht\\footnote{De laatste term wordt behandeld in dynamica en is nu dus nog niet belangrijk. $I$ is het draai-equivalent van massa (het `traagheidsmoment'), en $\\alpha$ is het draai-equivalent van versnelling (hoekversnelling, rad/s$^2$). Deze vergelijking is dus het draai-equivalent van de derde wet van Newton.} geldt:\n",         "\n",         " $$\\underbrace{\\sum \\M_G}_{\\text{gebonden}} = \\underbrace{\\sum\\M_{ext}}_{\\text{vrij}} + \\underbrace{\\sum_{i} \\r_{G i} \\times \\F_i}_{\\text{gebonden}} = \\underbrace{I_G \\v{\\alpha}}_{\\text{gebonden}}=\\v{0}$$\n",         "\n",         " De bovenstaande gebonden vectoren zijn gebonden aan de keus voor $G$ (welk punt je kiest om het moment omheen te bepalen). De term $I_G\\v{\\alpha}$ wordt overigens pas behandeld bij Dynamica, en hier is het het handigst om het zwaartepunt te kiezen, vandaar de letter $G$.\n",         "\\end{enumerate}\n",         "\n",         "\n",         " \\section{Meerdere vrijlichaamsdiagrammen}\n",         "\n",         "\\begin{enumerate}\n",         "\\item Als je een systeem hebt met precies twee contactpunten, waarop alleen krachten werken (dus geen momenten), dan zijn de resultante krachten even groot en tegengesteld, en hebben ze dezelfde werklijn\\footnote{Oefentip: toon dit aan.}. Dit heet een \\textbf{tweekrachtsstaaf} (</code>two force member’‘).“,”“,”\item Een \textbf{vakwerk} bestaat enkel uit two force members. Voor een vakwerk heb je de snedemethode en de knooppuntmethode. Meestal moet je eerst het hele vakwerk als star lichaam beschouwen en de reactiekrachten bepalen, en daarna (een van) deze twee methodes toepassen.“,”“,”\item Gebruik hierbij de tekenafspraak dat een staaf, die op \textbf{trek} belast wordt, een \textbf{positieve} kracht levert.“,”“,”\item \textbf{Snedemethode} (in 2D): trek de systeemgrens door drie staven (in 2D) of zes staven (in 3D) heen. Dan heb je een star lichaam met drie onbekende (trek)krachten in de richting van de doorgesneden staven.“,”“,”\item \textbf{Knooppuntmethode}: elk knooppunt kan je als een puntdeeltje beschouwen, en daarvan kan je het krachtenevenwicht bepalen.“,”“,”\item Een \textbf{nulstaaf} (<code>zero force member'') kan herkend worden aan het feit dat het de enige staaf is van een knooppunt dat (een component heeft dat) in een bepaalde richting loopt.\n",         "\n",         "\\item Een \\textbf{frame of mechanisme} bestaat uit meerdere starre lichamen, maar dit zijn niet allemaal two force members. Je hebt in zo'n geval te veel onbekenden om met één vrijlichaamsdiagram uit te rekenen. Je moet dan meerdere vrijlichaamsdiagrammen tekenen, net zolang todat je even veel vergelijkingen als onbekenden hebt. Elk extra vrijlichaamsdiagram levert drie extra vergelijkingen op (in 2D).\n",         "\\end{enumerate}\n",         "\n",         "\\section{Inwendige belasting}\n",         "\\begin{enumerate}\n",         "\\item Bij een snede door een 2D balk heb je:\n",         "\n",         "\\begin{enumerate}\n",         "\\item Normaalkracht $N$ in de looprichting van de balk.\n",         "\\item Afschuifkracht $V$ loodrecht op de balk.\n",         "\\item Buigmoment $M$.\n",         "\\end{enumerate}\n",         "\n",         "\\item Deze krachten kunnen bepaald worden door een vrijlichaamsdiagram te tekenen waarbij de snede onderdeel van de systeemgrens is.\n",         "\n",         "\\item Door de locatie van de snede als variabele te nemen (bijvoorbeeld $x$) kan je een $V$-diagram en $M$-diagram genereren: $V(x)$ en $M(x)$. \n",         "\n",         "\\item Als je de tekenafspraak\\footnote{Zie collegeslides.} gebruikt, geldt overigens:\n",         "\n",         "$$V(x) = \\frac{d}{dx}M(x)$$\n",         "\n",         "\\item Als er een verdeelde belasting $w(x)$ op de balk werkt (en je gebruikt de tekenafspraak), dan geldt ook:\n",         "\n",         "$$w(x) = \\frac{d}{dx}V(x)$$\n",         "\n",         "\\item Let op dat je vaak meerdere vrijlichaamsdiagrammen nodig hebt.\n",         "\n",         "\\end{enumerate}\n",         "\n",         "\\section{Virtuele arbeid}\n",         "\n",         "Arbeid geleverd door krachten $\\F_i$ en verplaatsingen $\\Delta\\v{r}_i$:\n",         "$$U = \\sum_i\\Delta\\v{r}_i\\cdot\\F_i$$\n",         "\n",         "Arbeid geleverd door momenten $\\M_i$ en rotaties $\\Delta\\v{\\theta}_i$:\n",         "$$U = \\sum_i\\Delta\\v{\\theta}_i\\cdot\\M_i$$\n",         "\n",         "Als een systeem in evenwicht is\\footnote{Zie de laatste pagina voor een bewijs.}, geldt voor de virtuele arbeid over kleine\\footnote{In document gebruiken we in plaats van $\\partial$ en $\\delta$ gewoon een $d$ (</code>abuse of notation’‘).} (<code>virtuele'') verplaatsingen $d\\v{r}$ en virtuele rotaties $d\\v{\\theta}$ :\n",         "$$d U = \\sum_i d\\v{r}_i\\cdot\\F_i + \\sum_j d\\v{\\theta}_j\\cdot\\v{M}_j=  0$$\n",         "\n",         "\\begin{enumerate}\n",         "    \\item Bepaal op welke aangrijpingspunten je de krachten weet en op welk aangrijpingspunt je de kracht wilt bepalen.\n",         "    \\item Vind een vrijheidsgraad waarmee deze punten bewegen. Dit is vaak een rotatie, dus vaak wordt $\\theta$ gebruikt. (Het kan ook een kleine verplaatsing zijn, dan wordt vaak $s$ gebruikt.)\n",         "    \\item Vind de positievectoren $\\v{r}_i$ van deze punten\\footnote{Als er momenten op meerdere lichamen werken, vind dan ook de virtuele rotaties $d\n",         "    \\v{\\theta}_j$.}, als functie van $\\theta$. \n",         "    \\item Vind de afgeleiden $d\\v{r}_i/d\\theta$. Schrijf om naar $d\\v{r}_i=(...)d\\theta$\n",         "    \\item Los op $dU = 0$.\n",         "\\end{enumerate}\n",         "\n",         "\n",         "\\section{Potenti\\\"ele energie}\n",         "\\begin{enumerate}\n",         "    \\item Voor een systeem waarop alleen conservatieve krachten werken, geldt: voor elke vrijheidsgraad $q$ is er evenwicht als de potenti\\\"ele energie $V$ daar constant is\\footnote{De reden is als volgt: als op een systeem alleen conservatieve krachten werken, is de verrichte arbeid $dU$ op het systeem gelijk aan de verloren potentiële energie van het systeem $dV$. We hebben al gezien dat voor een systeem in evenwicht $dU=0$, dus $dV=0$. Dus voor elke vrijheidsgraad $q$ die invloed heeft op $V$, moet gelden $dV/dq=0$.}. Oftewel:\n",         "\n",         "$$\\frac{d}{dq}V(q) = 0$$\n",         "\n",         "Net zoals bij virtuele arbeid hebben we meestal een hoek $\\theta$ of een afstand $s$ als vrijheidsgraad. Maar we schrijven hier steeds $q$ om het algemeen te houden.\n",         "\n",         "\\item Verder is dit evenwicht neutraal stabiel als ook geldt\\footnote{Want $d^2V/dq^2&lt;0$ zou betekenen: als je iets van het evenwichtspunt af gaat zitten, wordt $V$ minder. In een systeem waaarop alleen conservatieve krachten werken, is er dus potentiële energie omgezet in kinetische energie. De beweging zal dus versnellen.}:\n",         "\n",         "$$\\frac{d^2}{dq^2}V(q) = 0$$\n",         "\n",         "Als de tweede afgeleide positief is, is het evenwicht stabiel; als de tweede afgeleide negatief is, is het evenwicht instabiel.\n",         "\n",         "\\item Een mechanisme is in elke positie neutraal stabiel als er een oplossing voor $dV/dq=0$ is die onafhankelijk is van $q$. Dit wordt ook wel</code>statisch balanceren’’ of <code>zwaartekrachtcompensatie'' genoemd.\n",         "\n",         "\\item Voor een gewicht $mg$ en hoogte $h$ geldt:\n",         "$$V_g = mgh + C$$\n",         "\n",         "Hier is $C$ een (integratie)constante, want je kan het nulpunt van zwaarte-energie (de zogenoemde</code>datum’‘) plaatsen waar je wil. “,”“,”\item Voor een veer met stijfheid <span class="math inline">\(k\)</span> en uitrekking <span class="math inline">\(\\Delta s\)</span> geldt:“,”<span class="math display">\[V_k = \\frac{1}{2}k(\\Delta s)^2\]</span>“,”“,”\item Voor een ideale veer (``zero free length spring’’) geldt dat de uitrekking en de totale lengte van de veer gelijk zijn. Zo’n veer wordt vaak gebruikt bij neutraal stabiele mechanismen.“,”“,”\item Vaak moet je een (veer)lengte bepalen met de cosinusregel:“,”“,”<span class="math display">\[a^2 = b^2 + c^2 -2bc\\cos\\alpha\]</span>“,”“,”Deze moet je uit je hoofd kennen.“,”“,”\item Bij een mechanisme met meerdere vrijheidsgraden <span class="math inline">\(q_1\)</span> en <span class="math inline">\(q_2\)</span> moet je voor evenwicht hebben:“,”“,”<span class="math display">\[\\frac{d}{dq_1}V(q_1,q_2) = \\frac{d}{dq_2}V(q_1,q_2) = 0 \]</span>“,”“,”En voor een neutraal stabiel evenwicht moet je ook hebben:“,”“,”<span class="math display">\[\\frac{d}{dq_1}\\frac{d}{dq_1} V(q_1,q_2) = \\frac{d}{dq_1} \\frac{d}{dq_2}V(q_1,q_2) = \\frac{d}{dq_2} \\frac{d}{dq_1}V(q_1,q_2) = \\frac{d}{dq_2} \\frac{d}{dq_2}V(q_1,q_2) = 0 \]</span>“,”“,”Voor een systeem dat voor elke positie neutraal stabiel is, levert dit zesmaal dezelfde vergelijking op; alternatievelijk kan je zien dat er dezelfde oplossing is voor zowel <span class="math inline">\(dV/dq_1=0\)</span> en <span class="math inline">\(dV/dq_2=0\)</span> die onafhankelijk is van zowel <span class="math inline">\(q_1\)</span> als <span class="math inline">\(q_2\)</span>.“,”“,”\end{enumerate}“,”“,”“,”“,”“,”\section{Wrijving}“,”“,”\begin{enumerate}“,” \item Statische Coulombwrijving:“,”<span class="math display">\[F_W \\leq \\mu_s F_N\]</span>“,”“,”\item Dynamische Coulombwrijving:“,”<span class="math display">\[F_W = \\mu_d F_N\]</span>“,”“,”\item Riemwrijving (Euler–Eytelwein):“,”<span class="math display">\[F_{1} \\leq F_{2} e^{\\mu_s \\theta}\]</span>“,”“,”\item Rolweerstand:“,”<span class="math display">\[F_W = \\frac{a}{r} F_N\]</span>“,”Hier is <span class="math inline">\(a\)</span> de rolweerstandscoëfficiënt, met een lengte-eenheid, en <span class="math inline">\(r\)</span> is de radius van het wiel of de roller. “,”“,”\item Je hebt dus naast je drie vergelijkingen (in 2D) een extra vergelijking. Dus moet er een extra onbekende in je vrijlichaamsdiagram(men) zijn. Vaak is deze onbekende de locatie van <span class="math inline">\(F_N\)</span>: deze locatie bepaalt dan of het systeem gaat glijden of kantelen.“,”\end{enumerate}“,”\section{Geometrisch centrum}“,”“,”\begin{enumerate}“,” \item Twee volumes <span class="math inline">\(V_1\)</span> en <span class="math inline">\(V_2\)</span> met elk een geometrisch centrum\footnote{Vanaf hier gebruiken we ook tildes (<span class="math inline">\(\\tilde{x}\)</span>) om het geometrisch centrum aan te geven van een onderdeel; het streepje (<span class="math inline">\(\\bar{x}\)</span>) geeft het geometrisch centrum aan van het geheel. Dit streepje wordt in de wiskunde gebruikt om een gemiddelde aan te geven. Zowel het geometrisch centrum als de werklijn van een resultante kracht, zijn ook eigenlijk gewoon een gewogen gemiddelde, vandaar dat we deze notatie gebruiken.} <span class="math inline">\(\\tilde{\\r}_1\)</span> en <span class="math inline">\(\\tilde{\\r}_2\)</span>:“,” <span class="math display">\[V_{tot} = V_1 + V_2\]</span>“,”<span class="math display">\[\\bar{\\r} = \\frac{1}{V_{tot}}\\left(\\tilde{\\r}_1V_1 + \\tilde{\\r}_2V_2\\right)\]</span>“,”“,”Meer volumes:“,”<span class="math display">\[V_{tot} = \\sum_i V_i\]</span>“,”<span class="math display">\[\\bar{\\r} = \\frac{1}{V_{tot}}\\sum_i \\tilde{\\r}_i V_i\]</span>“,”“,”Dit kan je gebruiken om het geometrisch centrum te bepalen van een vorm die bestaat uit simpele onderdelen (zoals kubussen, prisma’s, cilinders, en bollen). Je kan ook volumes van elkaar aftrekken, bijvoorbeeld als je een kubus hebt met een cilindrisch gat erin.“,”“,”\item Integreren over oneindig veel kleine volumes <span class="math inline">\(dV\)</span>; oftewel het geometrisch centrum bepalen van een arbitraire vorm:“,”<span class="math display">\[V_{tot} = \\int_V dV\]</span>“,”<span class="math display">\[\\bar{\\r} = \\frac{1}{V_{tot}}\\int_V \\tilde{\\r} dV \]</span>“,”“,”\item Als het gaat om een 2D oppervlak, dan gebruiken we <span class="math inline">\(A\)</span> en <span class="math inline">\(dA\)</span> in plaats van <span class="math inline">\(V\)</span> en <span class="math inline">\(dV\)</span>. Als het gaat om een 1D lengte, dan gebruiken we <span class="math inline">\(L\)</span> en <span class="math inline">\(dL\)</span>.“,”“,”\item Geometrisch centrum <span class="math inline">\(\\bar{x}\\i+\\bar{y}\\j\)</span> bepalen van een staaf in de vorm <span class="math inline">\(y(x)\)</span> met <span class="math inline">\(x_0 &lt; x &lt; x_1\)</span>:“,”\begin{enumerate}“,” \item Neem <span class="math display">\[dL = \\sqrt{(dx)^2+(dy)^2} = \\sqrt{1+\\left(\\frac{dy}{dx}\\right)^2} dx\]</span>“,” \item Voor het geometrisch centrum van <span class="math inline">\(dL\)</span> geldt <span class="math inline">\(\\tilde{x}= x\)</span> en <span class="math inline">\(\\tilde{y} = y(x)\)</span>. “,” \item“,”“,” <span class="math display">\[L = \\int_L dL = \\int_{x_0}^{x_1}\\sqrt{1+\\left(\\frac{dy}{dx}\\right)^2} dx\]</span>“,” \item“,” “,”<span class="math display">\[\\bar{x} = \\frac{1}{L}\\int_L \\tilde{x} dL = \\frac{1}{L}\\int_{x_0}^{x_1} x \\sqrt{1+\\left(\\frac{dy}{dx}\\right)^2} dx\]</span>“,”“,”<span class="math display">\[\\bar{y} = \\frac{1}{L}\\int_L \\tilde{y} dL = \\frac{1}{L}\\int_{x_0}^{x_1} y(x) \\sqrt{1+\\left(\\frac{dy}{dx}\\right)^2} dx\]</span>“,”\end{enumerate}“,”“,”\item Geometrisch centrum <span class="math inline">\(\\bar{x}\\i+\\bar{y}\\j\)</span> bepalen van een oppervlak ingesloten onder een functie <span class="math inline">\(y(x)\)</span> met <span class="math inline">\(x_0 &lt; x &lt; x_1\)</span>:“,”“,”\begin{enumerate}“,” \item Neem <span class="math inline">\(dA = y(x) dx\)</span>.“,” \item Voor het geometrisch centrum van <span class="math inline">\(dA\)</span> geldt <span class="math inline">\(\\tilde{x}= x\)</span> en <span class="math inline">\(\\tilde{y}= y(x)/2\)</span>.“,” \item“,”“,” <span class="math display">\[ A = \\int_{x_0}^{x_1} y(x) dx\]</span>“,”“,” \item “,”“,”<span class="math display">\[\\bar{x} = \\frac{1}{A}\\int_A \\tilde{x} dA = \\frac{1}{A}\\int_{x_0}^{x_1} xy(x)dx\]</span>“,”“,”<span class="math display">\[\\bar{y} = \\frac{1}{A}\\int_A \\tilde{y} dA = \\frac{1}{A}\\int_{x_0}^{x_1} \\frac{y(x)}{2}\\cdot y(x)dx = \\frac{1}{2A}\\int_{x_0}^{x_1} y^2(x)dx\]</span>“,”“,”\end{enumerate}“,”“,”\item Je kan ook integreren over <span class="math inline">\(dy\)</span> in plaats van <span class="math inline">\(dx\)</span>, soms is dat makkelijker.“,”“,”“,”“,”\item Bij een cirkel moet je integreren over <span class="math inline">\(d\\theta\)</span> in plaats van <span class="math inline">\(dx\)</span>. Als de oorsprong in het midden van de cirkel ligt, kan je gebruiken: “,”“,”<span class="math display">\[x = r\\cos\\theta\]</span>“,”<span class="math display">\[y = r\\sin\\theta\]</span>“,”“,”Dan, voor alleen de rand van de cirkel:“,”<span class="math display">\[dL = r d\\theta,\\quad \\tilde{x}=r\\cos\\theta,\\quad \\tilde{y}=r\\sin\\theta\]</span>“,”“,”Voor het oppervlak van een cirkel (dit kan je vinden door elk partje als een driehoek te benaderen):“,”<span class="math display">\[dA = \\frac{r^2}{2} d\\theta,\\quad \\tilde{x}=\\frac{2}{3}r\\cos\\theta,\\quad \\tilde{y}=\\frac{2}{3}r\\sin\\theta\]</span>“,”“,”\item Geometrisch centrum <span class="math inline">\(\\bar{x}\\i+\\bar{y}\\j+\\bar{z}\\k\)</span> bepalen van een oppervlak ingesloten onder een functie <span class="math inline">\(z(x, y)\)</span> met <span class="math inline">\(x_0 &lt; x &lt; x_1\)</span> en <span class="math inline">\(y_0 &lt; y &lt; y_1\)</span>:“,”“,”\begin{enumerate}“,” \item Neem <span class="math display">\[dV = z(x, y) dx dy\]</span>“,” \item Voor het geometrisch centrum van <span class="math inline">\(dA\)</span> geldt <span class="math inline">\(\\tilde{x}= x\)</span>, <span class="math inline">\(\\tilde{y}= y\)</span>, en <span class="math inline">\(\\tilde{z}= z(x,y)/2\)</span>.“,” \item <span class="math display">\[V = \\iint_V dV = \\int_{y_0}^{y_1}\\int_{x_0}^{x_1}z(x, y) dx dy\]</span>“,”“,” \item <span class="math display">\[\\bar{x} = \\frac{1}{V}\\iint_V \\tilde{x}dV = \\frac{1}{V} \\int_{y_0}^{y_1}\\int_{x_0}^{x_1}xz(x, y) dx dy\]</span>“,”<span class="math display">\[\\bar{y} = \\frac{1}{V}\\iint_V \\tilde{y}dV = \\frac{1}{V} \\int_{y_0}^{y_1}\\int_{x_0}^{x_1}yz(x, y) dx dy\]</span>“,”<span class="math display">\[\\bar{z} = \\frac{1}{V}\\iint_V \\tilde{z}dV = \\frac{1}{V} \\int_{y_0}^{y_1}\\int_{x_0}^{x_1}\\frac{z(x, y)}{2}\\cdot z(x, y) dx dy = \\frac{1}{2V} \\int_{y_0}^{y_1}\\int_{x_0}^{x_1} z^2(x, y) dx dy \]</span>“,”\end{enumerate}“,”“,”\end{enumerate}“,”“,”\section{Hydrostatica}“,”“,”“,”\begin{enumerate}“,” \item De druk <span class="math inline">\(p\)</span> die een vloeistof uitoefent op zijn omgeving is afhankelijk van de dichtheid <span class="math inline">\(\\rho\)</span>, de zwaartekrachtsversnelling <span class="math inline">\(g\)</span>, en de lokale(!) diepte <span class="math inline">\(h\)</span>.“,”“,”<span class="math display">\[p(h) = \\underbrace{\\rho g h}_{\\text{geeft N/m}^2}\]</span>“,”“,”\item Vaak is het handig om een deel van het water mee te nemen in de systeemgrens. Dan is het gewicht van het water afhankelijk van het getekende oppervlak dat water voorstelt <span class="math inline">\(A_{water}\)</span>. Dit geeft een verdeelde belasting, omdat je nu de zwaartekracht neemt per eenheid lengte loodrecht op het vlak van de tekening.“,”“,”<span class="math display">\[w_{g,water} = \\underbrace{A_{water}\\rho g}_{\\text{geeft N/m}}\]</span>“,”“,”\item Alternatievelijk kan in 3D een lengte <span class="math inline">\(b\)</span> loodrecht op het vlak van de tekening gebruikt worden, dan geldt:“,”“,”<span class="math display">\[w(h) = \\underbrace{\\rho g h b}_{\\text{geeft N/m}}\]</span>“,”“,”<span class="math display">\[F_{g,water} = \\underbrace{V_{water}\\rho g = A_{water}b\\rho g}_{\\text{geeft N}}\]</span>“,”“,”\end{enumerate}“,”“,”\section<em>{Andere samenvattingen}“,”Disclaimer: de auteur is niet inhoudelijk verantwoordelijk voor deze vakken. Deze teksten kunnen dus fouten bevatten, en aan deze teksten kunnen geen rechten worden ontleend.“,”“,”\begin{itemize}“,” \item Sterkteleer, \url{https://www.overleaf.com/read/qqmjnhhxczyp#dbaca1}“,” \item Dynamica, \url{https://www.overleaf.com/read/gprmxxxnqtzf#83f127}“,”\end{itemize}“,”“,”\newpage“,”“,”\section</em>{Extra: bewijs virtuele arbeid voor meerdere starre lichamen}“,”\begin{enumerate}“,” \item Neem starre lichamen <span class="math inline">\(i=1, 2,...\)</span> en op elk lichaam werken externe krachten <span class="math inline">\(j=1, 2, ...\)</span> en externe momenten <span class="math inline">\(k=1, 2,...\)</span>“,” \item Dan is de totale virtuele arbeid:“,” <span class="math display">\[dU = \\sum_i\\left( \\sum_j\\left( \\F_{i,j} \\cdot d\\r_{i, j}\\right) + \\sum_k\\left(\\M_{i, k}\\cdot d\\v{\\theta}_i\\right)\\right)\]</span>“,” \item Links: de verplaatsing van een elk punt <span class="math inline">\(d\\r_{i, j}\)</span> is gelijk aan de verplaatsing van een referentiepunt op dat lichaam <span class="math inline">\(d\\r_{O_i}\)</span> plus een rotatieterm <span class="math inline">\(d\\v{\\theta}_i \\times \\r_{O_i, j}\)</span>. Rechts: inproduct is distributief over optellen en alleen de <span class="math inline">\(\\M\)</span>-term is afhankelijk van <span class="math inline">\(k\)</span>.“,” <span class="math display">\[dU = \\sum_i\\left( \\sum_j\\left( \\F_{i,j} \\cdot \\left(d\\r_{O_i} + d\\v{\\theta}_i \\times \\r_{O_i, j}\\right)\\right) +  \\sum_k\\M_{i, k}\\cdot d\\v{\\theta}_i \\right)\]</span>“,” \item Links: inproduct is distributief over optellen. Rechts: inproduct is commutatief. “,” <span class="math display">\[dU = \\sum_i\\left( \\sum_j\\left( \\F_{i,j} \\cdot d\\r_{O_i}\\right) + \\sum_j\\left(\\F_{i,j}\\cdot \\left( d\\v{\\theta}_i \\times \\r_{O_i, j}\\right)\\right) +  d\\v{\\theta}_i \\cdot \\sum_k\\M_{i, k}\\right)\]</span>“,” \item Links: inproduct is distributief over optellen en alleen de <span class="math inline">\(\\F\)</span> term is afhankelijk van <span class="math inline">\(j\)</span>. Midden: gebruik <span class="math inline">\(\\v{a} \\cdot (\\v{b} \\times \\v{c}) = \\v{b} \\cdot (\\v{c} \\times \\v{a})\)</span>.“,” <span class="math display">\[dU = \\sum_i\\left( \\sum_j\\F_{i,j} \\cdot d\\r_{O_i} + \\sum_j\\left( d\\v{\\theta}_i\\cdot \\left(\\r_{O_i, j} \\times \\F_{i,j}\\right)\\right)+ d\\v{\\theta}_i \\cdot \\sum_k\\M_{i, k}\\right)\]</span>“,” \item Links: <span class="math inline">\(\\sum_j\\F_{i,j}\)</span> is de som van krachten op één lichaam, dus gelijk aan <span class="math inline">\(\\v{0}\)</span>. Midden: inproduct is distributief over optellen, en <span class="math inline">\(d\\v{\\theta}_i\)</span> is onafhankelijk van <span class="math inline">\(\\j\)</span>.“,” <span class="math display">\[dU = \\sum_i\\left( \\v{0} \\cdot d\\r_{O_i} +  d\\v{\\theta}_i\\cdot \\sum_j\\left(\\r_{O_i, j} \\times \\F_{i,j}\\right)+ d\\v{\\theta}_i \\cdot \\sum_k\\M_{i, k}\\right)\]</span>“,” \item Links: inproduct geeft 0. Rechts: inproduct is distributief over optellen.“,” <span class="math display">\[dU = \\sum_i\\left( 0 +  d\\v{\\theta}_i\\cdot \\left(\\sum_j\\left(\\r_{O_i, j} \\times \\F_{i,j}\\right)+  \\sum_k\\M_{i, k}\\right)\\right)\]</span>“,” \item Rechterterm is de som van momenten op één lichaam, en dat is gelijk aan <span class="math inline">\(\\v{0}\)</span>.“,” <span class="math display">\[dU = \\sum_i\\left(  d\\v{\\theta}_i\\cdot \\v{0}\\right) = \\sum_i 0 = 0\]</span>“,”\end{enumerate}“,”“,”\section*{Interne richtlijnen tentaminering}“,”\begin{enumerate}“,” \item De tentaminering bestaat uit een Tussentoets <span class="math inline">\(TT\)</span>, een Tentamen <span class="math inline">\(T\)</span> met een Tentamen Extra Opgave <span class="math inline">\(TEO\)</span>, een Hertentamen <span class="math inline">\(H\)</span> met een Hentamen Extra Opgave <span class="math inline">\(HEO\)</span>, en een eventuele Bonusregeling <span class="math inline">\(B\)</span>.“,” “,” \item Het eindcijfer <span class="math inline">\(C\)</span> wordt als volgt berekend.“,” <span class="math display">\[C = \\min\\left(\\frac{1}{10}\\max(TT, TEO, HEO) + \\frac{9}{10}\\max(T, H) + B, 10\\right)\]</span>“,”“,” \item Deelcijfers worden tussendoor afgerond op 0.1, volgens de TU-richtlijnen.“,”“,” \item Let op: deelcijfers tellen alleen mee als je een 5.0 of hoger haalt. Anders tellen ze door in de berekening als 0.“,”“,” \item Deelcijfers worden als volgt berekend.“,”“,” <span class="math display">\[\\frac{\\text{behaalde punten}}{(\\text{maximaal te behalen punten}) - (\\text{eventuele normering})}\\cdot9+1\]</span>“,”“,” \item TT bevat in principe vier vragen: “,” \begin{enumerate}“,” \item Leerdoel 1 (vectoren)“,” \item Leerdoelen 2, 3 en/of 4 (evenwicht in 2D, inclusief systeemvorming en diagram tekenen)“,” \item Leerdoelen 2, 3 en/of 4 (evenwicht in 3D, inclusief systeemvorming en diagram tekenen)“,” \item Leerdoelen 5 en/of 6 (resulterende kracht en werklijn)“,” \end{enumerate}“,”“,” \item T en H bevatten in principe zes vragen:“,” \begin{enumerate}“,” \item Leerdoel 1 (vectoren)“,” \item Leerdoelen 2, 3, 4, 7, en/of 8 (vakwerken, frames, en/of machines)“,” \item Leerdoelen 9 en/of 10 (inwendige belasting en/of V- en M-lijn)“,” \item Leerdoelen 11 en/of 12 (virtuele arbeid en/of potentiële energie)“,” \item Leerdoelen 2, 3, 4, en/of 14 (wrijving)“,” \item Leerdoelen 13 en/of 15 (geometrisch centrum en/of hydrostatica)“,” \end{enumerate}“,” “,” Elk leerdoel, en elke denk- en rekenstap binnen elke methode, wordt niet meer dan éénmaal getoetst, tenzij het Tussentoetsstof is (Leerdoelen 1 t/m 6).“,”“,” \item Het aantal te behalen punten wordt gegeven per deelvraag.“,”“,” \item Deelvragen zijn onafhankelijk van elkaar. Binnen één deelvraag kan om meerdere resultaten gevraagd worden, die wel afhankelijk van elkaar zijn. Elk gevraagd resultaat is dikgedrukt.“,”“,” \item TEO en HEO bestaan elk uit één vraag uit TT.“,”“,” \item TT heeft in principe 27 maximaal te behalen punten. T en H hebben elk 36 maximaal te behalen punten. TEO en HEO hebben elk 9 maximaal te behalen punten. Dit is een cijferresolutie van 1/3, 1/4, respectievelijk 1.“,”“,” \item Elk punt is één denk- of rekenstap. Voor elke gemaakte denk- of rekenfout kan een student maximaal één punt verliezen. In andere woorden: er wordt rekening gehouden met doorrekenfouten. Dit geldt niet, als een fout de uitwerking zodanig versimpeld, dat aan andere denk- of rekenstappen niet meer toegekomen wordt.“,”“,” \item De normering bestaat uitsluitend uit het aantal punten, waarbij niet aan de richtlijnen is voldaan, voornamelijk betreft leerdoelen, deelvragen, punten, en denk- en rekenstappen. Als een normering wordt toegepast, is dat niet om een bepaald slagingspercentage te behalen.“,”“,” \item De normering en de onderbouwing worden gepubliceerd als Announcement en als errata bij Oude Tentamens.“,” “,”\end{enumerate}“,”“,”\newpage“,”“,”\end{document}” ] } ], “metadata”: { “kernelspec”: { “name”: “python3”, “language”: “python”, “display_name”: “Python 3 (ipykernel)”, “path”: “/Library/Frameworks/Python.framework/Versions/3.12/share/jupyter/kernels/python3” } }, “nbformat”: 4, “nbformat_minor”: 4 }</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>